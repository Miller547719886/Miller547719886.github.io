<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="江大第一切图仔。">
<meta property="og:type" content="website">
<meta property="og:title" content="Rufer's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Rufer's Blog">
<meta property="og:description" content="江大第一切图仔。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rufer's Blog">
<meta name="twitter:description" content="江大第一切图仔。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Rufer's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?485fcf1afa60502f13f62c26dc2f39b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Rufer's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">煜峰的博客</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/01/2017-3-7/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Rufer">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Rufer's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Rufer's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/2017-3-7/" itemprop="url">
                  前端代码规范-css/sass(scss)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T23:40:02+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/2017-3-7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/01/2017-3-7/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##ID and class naming</p>
<p>ID和class(类)名总是使用可以反应元素目的和用途的名称，或其他通用名称。代替表象和晦涩难懂的名称。</p>
<p>应该首选具体和反映元素目的的名称，因为这些是最可以理解的，而且发生变化的可能性最小。</p>
<p>通用名称只是多个元素的备用名，他们兄弟元素之间是一样的，没有特别意义。<br>区分他们，使他们具有特殊意义，通常需要为“帮手”。</p>
<p>尽管class(类)名和ID 的语义化对于计算机解析来说没有什么实际的意义，<br>语义化的名称 通常是正确的选择，因为它们所代表的信息含义，不包含表现的限制。</p>
<p>不推荐</p>
<pre><code>.fw-800 {
  font-weight: 800;
}

.red {
  color: red;
}
</code></pre><p>推荐</p>
<pre><code>.heavy {
  font-weight: 800;
}

.important {
  color: red;
}
</code></pre><p>##合理的避免使用ID</p>
<p>一般情况下ID不应该被应用于样式。<br>ID的样式不能被复用并且每个页面中你只能使用一次ID。<br>使用ID唯一有效的是确定网页或整个站点中的位置。<br>尽管如此，你应该始终考虑使用class，而不是id，除非只使用一次。</p>
<p>不推荐</p>
<pre><code>#content .title {
  font-size: 2em;
}
</code></pre><p>推荐</p>
<pre><code>.content .title {
  font-size: 2em;
}
</code></pre><p>另一个反对使用ID的观点是含有ID选择器权重很高。<br>一个只包含一个ID选择器权重高于包含1000个class(类)名的选择器，这使得它很奇怪。</p>
<pre><code>// 这个选择器权重高于下面的选择器
#content .title {
  color: red;
}

// than this selector!
html body div.content.news-content .title.content-title.important {
  color: blue;
}
</code></pre><p>##CSS选择器中避免标签名</p>
<p>当构建选择器时应该使用清晰， 准确和有语义的class(类)名。不要使用标签选择器。 如果你只关心你的class(类)名<br>，而不是你的代码元素，这样会更容易维护。</p>
<p>从分离的角度考虑,在表现层中不应该分配html标记/语义。<br>它可能是一个有序列表需要被改成一个无序列表，或者一个div将被转换成article。<br>如果你只使用具有实际意义的class(类)名，<br>并且不使用元素选择器，那么你只需要改变你的html标记，而不用改动你的CSS。</p>
<p>不推荐</p>
<pre><code>div.content &gt; header.content-header &gt; h2.title {
  font-size: 2em;
}
</code></pre><p>推荐</p>
<pre><code>.content &gt; .content-header &gt; .title {
  font-size: 2em;
}
</code></pre><p>##尽可能的精确</p>
<p>很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。<br>有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。<br>然而，在任何情况下，这是一个非常不好的做法。<br>如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。</p>
<p>考虑下面的DOM:</p>
<pre><code>&lt;article class=&quot;content news-content&quot;&gt;
  &lt;span class=&quot;title&quot;&gt;News event&lt;/span&gt;
  &lt;div class=&quot;content-body&quot;&gt;
    &lt;div class=&quot;title content-title&quot;&gt;
      Check this out
    &lt;/div&gt;

    &lt;p&gt;This is a news article content&lt;/p&gt;

    &lt;div class=&quot;teaser&quot;&gt;
      &lt;div class=&quot;title&quot;&gt;Buy this&lt;/div&gt;
      &lt;div class=&quot;teaser-content&quot;&gt;Yey!&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/article&gt;
</code></pre><p>下面的CSS将应用于有title类的全部三个元素。<br>然后，要解决content类下的title类 和 teaser类下的title类下不同的样式，这将需要更精确的选择器再次重写他们的样式。</p>
<p>不推荐</p>
<pre><code>.content .title {
  font-size: 2rem;
}
</code></pre><p>推荐</p>
<pre><code>.content &gt; .title {
  font-size: 2rem;
}

.content &gt; .content-body &gt; .title {
  font-size: 1.5rem;
}

.content &gt; .content-body &gt; .teaser &gt; .title {
  font-size: 1.2rem;
}
</code></pre><p>##缩写属性</p>
<p>CSS提供了各种缩写属性（如 font 字体）应该尽可能使用，即使在只设置一个值的情况下。</p>
<p>使用缩写属性对于代码效率和可读性是有很有用的。</p>
<p>不推荐</p>
<pre><code>border-top-style: none;
font-family: palatino, georgia, serif;
font-size: 100%;
line-height: 1.6;
padding-bottom: 2em;
padding-left: 1em;
padding-right: 1em;
padding-top: 0;
</code></pre><p>推荐</p>
<pre><code>border-top: 0;
font: 100%/1.6 palatino, georgia, serif;
padding: 0 1em 2em;
</code></pre><p>##0 和 单位</p>
<p>省略“0”值后面的单位。不要在0值后面使用单位，除非有值。</p>
<p>不推荐</p>
<pre><code>padding-bottom: 0px;
margin: 0em;
</code></pre><p>推荐</p>
<pre><code>padding-bottom: 0;
margin: 0;
</code></pre><p>##十六进制表示法</p>
<p>在可能的情况下，使用3个字符的十六进制表示法。<br>颜色值允许这样表示，<br>3个字符的十六进制表示法更简短。</p>
<p>始终使用小写的十六进制数字。</p>
<p>不推荐</p>
<pre><code>color: #FF33AA;
</code></pre><p>推荐</p>
<pre><code>color: #f3a;
</code></pre><p>##ID 和 Class（类） 名的分隔符</p>
<p>使用连字符（中划线）分隔ID和Class（类）名中的单词。为了增强课理解性，在选择器中不要使用除了连字符（中划线）以为的任何字符（包括没有）来连接单词和缩写。</p>
<p>另外，作为该标准，预设属性选择器能识别连字符（中划线）作为单词[attribute|=value]的分隔符，<br>所以最好的坚持使用连字符作为分隔符。</p>
<p>不推荐</p>
<pre><code>.demoimage {}
.error_status {}
</code></pre><p>推荐</p>
<pre><code>#video-id {}
.ads-sample {}
</code></pre><p>##Hacks</p>
<p>避免用户代理检测以及CSS“hacks” – 首先尝试不同的方法。通过用户代理检测或特殊的CSS滤镜，变通的方法和 hacks 很容易解决样式差异。为了达到并保持一个有效的和可管理的代码库，这两种方法都应该被认为是最后的手段。换句话说，从长远来看，用户代理检测和hacks<br>会伤害项目，作为项目往往应该采取阻力最小的途径。也就是说，轻易允许使用用户代理检测和hacks 以后将过于频繁。</p>
<p>##声明顺序</p>
<p>这是一个选择器内书写CSS属性顺序的大致轮廓。这是为了保证更好的可读性和可扫描重要。</p>
<p>作为最佳实践，我们应该遵循以下顺序（应该按照下表的顺序）：</p>
<p>结构性属性：</p>
<ol>
<li>display<ol>
<li>position, left, top, right etc.</li>
<li>overflow, float, clear etc.</li>
<li>margin, padding</li>
</ol>
</li>
<li>表现性属性： <ol>
<li>background, border etc.</li>
<li>font, text</li>
</ol>
</li>
</ol>
<p>不推荐</p>
<pre><code>.box {
    font-family: &apos;Arial&apos;, sans-serif;
    border: 3px solid #ddd;
    left: 30%;
    position: absolute;
    text-transform: uppercase;
        background-color: #eee;
    right: 30%;
    isplay: block;
    font-size: 1.5rem;
    overflow: hidden;
    padding: 1em;
    margin: 1em;
}
</code></pre><p>推荐</p>
<pre><code>.box {
    display: block;
    position: absolute;
    left: 30%;
    right: 30%;
    overflow: hidden;
    margin: 1em;
    padding: 1em;
    background-color: #eee;
    border: 3px solid #ddd;
    font-family: &apos;Arial&apos;, sans-serif;
    font-size: 1.5rem;
    text-transform: uppercase;
}
</code></pre><p>##声明结束</p>
<p>为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。</p>
<p>不推荐</p>
<pre><code>.test {
  display: block; height: 100px
}
</code></pre><p>推荐</p>
<pre><code>.test {
  display: block;
  height: 100px;
}
</code></pre><p>##属性名结束 </p>
<p>属性名的冒号后使用一个空格。出于一致性的原因，<br>属性和值（但属性和冒号之间没有空格）的之间始终使用一个空格。</p>
<p>不推荐</p>
<pre><code>h3 {
  font-weight:bold;
}
</code></pre><p>推荐</p>
<pre><code>h3 {
  font-weight: bold;
}
</code></pre><p>##选择器和声明分离</p>
<p>每个选择器和属性声明总是使用新的一行。</p>
<p>不推荐</p>
<pre><code>a:focus, a:active {
  position: relative; top: 1px;
}
</code></pre><p>推荐</p>
<pre><code>h1,
h2,
h3 {
  font-weight: normal;
  line-height: 1.2;
}
</code></pre><p>##规则分隔</p>
<p>规则之间始终有一个空行（双换行符）分隔。</p>
<p>推荐</p>
<pre><code>html {
  background: #fff;
}

body {
  margin: auto;
  width: 50%;
}
</code></pre><p>##CSS引号</p>
<p>属性选择器或属性值用双引号（””），而不是单引号（”）括起来。<br>URI值（url()）不要使用引号。</p>
<p>不推荐</p>
<pre><code>@import url(&apos;//cdn.com/foundation.css&apos;);

html {
  font-family: &apos;open sans&apos;, arial, sans-serif;
}

body:after {
  content: &apos;pause&apos;;
}
</code></pre><p>推荐</p>
<pre><code>@import url(//cdn.com/foundation.css);

html {
  font-family: &quot;open sans&quot;, arial, sans-serif;
}

body:after {
  content: &quot;pause&quot;;
}
</code></pre><p>##选择器嵌套 (SCSS)</p>
<p>在Sass中你可以嵌套选择器，这可以使代码变得更清洁和可读。嵌套所有的选择器，但尽量避免嵌套没有任何内容的选择器。<br>如果你需要指定一些子元素的样式属性，而父元素将不什么样式属性，<br>可以使用常规的CSS选择器链。<br>这将防止您的脚本看起来过于复杂。</p>
<p>不推荐</p>
<pre><code>// Not a good example by not making use of nesting at all
.content {
  display: block;
}

.content &gt; .news-article &gt; .title {
  font-size: 1.2em;
}
</code></pre><p>不推荐</p>
<pre><code>// Using nesting is better but not in all cases
// Avoid nesting when there is no attributes and use selector chains instead
.content {
  display: block;

  &gt; .news-article {
    &gt; .title {
      font-size: 1.2em;
    }
  }
}
</code></pre><p>推荐</p>
<pre><code>// This example takes the best approach while nesting but use selector chains where possible
.content {
  display: block;

  &gt; .news-article &gt; .title {
    font-size: 1.2em;
  }
}
</code></pre><p>##嵌套中引入 空行 (SCSS)</p>
<p>嵌套选择器和CSS属性之间空一行。</p>
<p>不推荐</p>
<pre><code>.content {
  display: block;
  &gt; .news-article {
    background-color: #eee;
    &gt; .title {
      font-size: 1.2em;
    }
    &gt; .article-footnote {
      font-size: 0.8em;
    }
  }
}
</code></pre><p>推荐</p>
<pre><code>.content {
  display: block;

  &gt; .news-article {
    background-color: #eee;

    &gt; .title {
      font-size: 1.2em;
    }

    &gt; .article-footnote {
      font-size: 0.8em;
    }
  }
}
</code></pre><p>##上下文媒体查询(SCSS)</p>
<p>在Sass中，当你嵌套你的选择器时也可以使用上下文媒体查询。<br>在Sass中，你可以在任何给定的嵌套层次中使用媒体查询。<br>由此生成的CSS将被转换，这样的媒体查询将包裹选择器的形式呈现。</p>
<p>这技术非常方便，<br>有助于保持媒体查询属于的上下文。</p>
<p>第一种方法这可以让你先写你的手机样式，然后在任何你需要的地方<br>用上下文媒体查询以提供桌面样式。</p>
<p>不推荐</p>
<pre><code>// This mobile first example looks like plain CSS where the whole structure of SCSS is repeated
// on the bottom in a media query. This is error prone and makes maintenance harder as it&apos;s not so easy to relate
// the content in the media query to the content in the upper part (mobile style)

.content-page {
  font-size: 1.2rem;

  &gt; .main {
    background-color: whitesmoke;

        &gt; .latest-news {
      padding: 1rem;

      &gt; .news-article {
        padding: 1rem;

        &gt; .title {
          font-size: 2rem;
        }
      }
    }

    &gt; .content {
      margin-top: 2rem;
      padding: 1rem;
    }
  }

  &gt; .page-footer {
    margin-top: 2rem;
    font-size: 1rem;
  }
}

@media screen and (min-width: 641px) {
  .content-page {
    font-size: 1rem;

    &gt; .main &gt; .latest-news &gt; .news-article &gt; .title {
      font-size: 3rem;
    }

    &gt; .page-footer {
      font-size: 0.8rem;
    }
  }
}    
</code></pre><p>推荐</p>
<pre><code>// This is the same example as above but here we use contextual media queries in order to put the different styles
// for different media into the right context.

.content-page {
  font-size: 1.2rem;

  @media screen and (min-width: 641px) {
    font-size: 1rem;
  }

  &gt; .main {
    background-color: whitesmoke;

    &gt; .latest-news {
      padding: 1rem;

      &gt; .news-article {
        padding: 1rem;

        &gt; .title {
          font-size: 2rem;

          @media screen and (min-width: 641px) {
            font-size: 3rem;
          }
        }
      }
    }

    &gt; .content {
      margin-top: 2rem;
      padding: 1rem;
    }
  }

  &gt; .page-footer {
    margin-top: 2rem;
    font-size: 1rem;

    @media screen and (min-width: 641px) {
      font-size: 0.8rem;
    }
  }
}
</code></pre><p>##嵌套顺序和父级选择器(SCSS)</p>
<p>当使用Sass的嵌套功能的时候，<br>重要的是有一个明确的嵌套顺序，<br>以下内容是一个SCSS块应具有的顺序。</p>
<ol>
<li>当前选择器的样式属性</li>
<li>父级选择器的伪类选择器 (:first-letter, :hover, :active etc)</li>
<li>伪类元素 (:before and :after)</li>
<li>父级选择器的声明样式 (.selected, .active, .enlarged etc.)</li>
<li>用Sass的上下文媒体查询</li>
<li>子选择器作为最后的部分</li>
</ol>
<p>The following example should illustrate how this ordering will achieve a clear structure while making use of the Sass parent selector.</p>
<p>推荐</p>
<pre><code>.product-teaser {
  // 1. Style attributes
  display: inline-block;
  padding: 1rem;
  background-color: whitesmoke;
  color: grey;

  // 2. Pseudo selectors with parent selector
  &amp;:hover {
    color: black;
  }

  // 3. Pseudo elements with parent selector
  &amp;:before {
    content: &quot;&quot;;
    display: block;
    border-top: 1px solid grey;
  }

  &amp;:after {
    content: &quot;&quot;;
    display: block;
    border-top: 1px solid grey;
  }

  // 4. State classes with parent selector
  &amp;.active {
    background-color: pink;
    color: red;

    // 4.2. Pseuso selector in state class selector
    &amp;:hover {
      color: darkred;
    }
  }

  // 5. Contextual media queries
  @media screen and (max-width: 640px) {
    display: block;
    font-size: 2em;
      }

  // 6. Sub selectors
  &gt; .content &gt; .title {
    font-size: 1.2em;

    // 6.5. Contextual media queries in sub selector
    @media screen and (max-width: 640px) {
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }
  }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/01/2017-3-10/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Rufer">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Rufer's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Rufer's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/2017-3-10/" itemprop="url">
                  前端代码规范-一般规范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T23:40:02+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/2017-3-10/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/01/2017-3-10/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##文件/资源命名</p>
<p>在 web 项目中，所有的文件名应该都遵循同一命名约定。以可读性而言，减号（-）是用来分隔文件名的不二之选。同时它也是常见的 URL 分隔符（i.e. //example.com/blog/my-blog-entry or //s.example.com/images/big-black-background.jpg），所以理所当然的，减号应该也是用来分隔资源名称的好选择。</p>
<p>请确保文件命名总是以字母开头而不是数字。而以特殊字符开头命名的文件，一般都有特殊的含义与用处（比如 compass[^1] 中的下划线就是用来标记跳过直接编译的文件用的）。</p>
<p>资源的字母名称必须全为小写，这是因为在某些对大小写字母敏感的操作系统中，当文件通过工具压缩混淆后，或者人为修改过后，大小写不同而导致引用文件不同的错误，很难被发现。</p>
<p>还有一些情况下，需要对文件增加前后缀或特定的扩展名（比如 .min.js, .min.css），抑或一串前缀（比如 3fa89b.main.min.css）。这种情况下，建议使用点分隔符来区分这些在文件名中带有清晰意义的元数据。</p>
<p>不推荐<br>    MyScript.js<br>    myCamelCaseName.css<br>    i_love_underscores.html<br>    1001-scripts.js<br>    my-file-min.css</p>
<p>推荐<br>    my-script.js<br>    my-camel-case-name.css<br>    i-love-underscores.html<br>    thousand-and-one-scripts.js<br>    my-file.min.css</p>
<p>##协议</p>
<p>不要指定引入资源所带的具体协议。</p>
<p>当引入图片或其他媒体文件，还有样式和脚本时，URLs 所指向的具体路径，不要指定协议部分（http:, https:），除非这两者协议都不可用。</p>
<p>不指定协议使得 URL 从绝对的获取路径转变为相对的，在请求资源协议无法确定时非常好用，而且还能为文件大小节省几个字节。</p>
<p>不推荐<br>    <script src="http://cdn.com/foundation.min.js"></script></p>
<p>推荐<br>    <script src="//cdn.com/foundation.min.js"></script></p>
<p>不推荐<br>    .example {<br>        background: url(<a href="http://static.example.com/images/bg.jpg" target="_blank" rel="external">http://static.example.com/images/bg.jpg</a>);<br>    }</p>
<p>推荐<br>    .example {<br>        background: url(//static.example.com/images/bg.jpg);<br>    }</p>
<p>##文本缩进</p>
<p>一次缩进两个空格。</p>
<pre><code>&lt;ul&gt;
  &lt;li&gt;Fantastic&lt;/li&gt;
  &lt;li&gt;Great&lt;/li&gt;
  &lt;li&gt;
    &lt;a href=&quot;#&quot;&gt;Test&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

@media screen and (min-width: 1100px) {
  body {
      font-size: 100%;
  }
}

(function(){
  var x = 10;
  function y(a, b) {
  return {
     result: (a + b) * x
    }
  }
}());
</code></pre><p>##注释</p>
<p>注释是你自己与你的小伙伴们了解代码写法和目的的唯一途径。特别是在写一些看似琐碎的无关紧要的代码时，由于记忆点不深刻，注释就变得尤为重要了。</p>
<p>编写自解释代码只是一个传说，没有任何代码是可以完全自解释的。而代码注释，则是永远也不嫌多。</p>
<p>当你写注释时一定要注意：不要写你的代码都干了些什么，而要写你的代码为什么要这么写，背后的考量是什么。当然也可以加入所思考问题或是解决方案的链接地址。</p>
<p>不推荐<br>    var offset = 0;<br>    if(includeLabels) {<br>        // Add offset of 20<br>        offset = 20;<br>    }</p>
<p>推荐<br>    var offset = 0;<br>    if(includeLabels) {<br>           // If the labels are included we need to have a minimum offset of 20 pixels<br>        // We need to set it explicitly because of the following bug: <a href="http://somebrowservendor.com/issue-tracker/ISSUE-1" target="_blank" rel="external">http://somebrowservendor.com/issue-tracker/ISSUE-1</a><br>        offset = 20;<br>    }</p>
<p>一些注释工具可以帮助你写出更好的注释。JSDoc 或 YUIDoc 就是用来写 JavaScript 注释用的。你甚至可以使用工具来为这些注释生成文档，这也是激励开发者们写注释的一个好方法，因为一旦有了这样方便的生成文档的工具，他们通常会开始花更多时间在注释细节上。</p>
<p>##代码检查</p>
<p>对于比较宽松自由的编程语言来说，严格遵循编码规范和格式化风格指南就显得极为重要。遵循规范固然很好，但是有自动化流程来确保其执行情况，岂不更佳。Trust is good, control is better.</p>
<p>对于 JavaScript，建议使用 JSLint 或 JSHint。</p>
<p>[^1]:Compass 是一个基于 Sass 开源的 CSS 框架，而 Sass 是一个非常流行的 CSS 预编译器。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/01/2017-3-8/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Rufer">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Rufer's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Rufer's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/2017-3-8/" itemprop="url">
                  前端代码规范-JavaScript
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T23:40:02+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/2017-3-8/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/01/2017-3-8/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##全局命名空间污染与 IIFE</p>
<p>总是将代码包裹成一个 IIFE(Immediately-Invoked Function Expression)，用以创建独立隔绝的定义域。这一举措可防止全局命名空间被污染。</p>
<p>IIFE 还可确保你的代码不会轻易被其它全局命名空间里的代码所修改（i.e. 第三方库，window 引用，被覆盖的未定义的关键字等等）。</p>
<p>不推荐</p>
<pre><code>var x = 10,
    y = 100;

// Declaring variables in the global scope is resulting in global scope pollution. All variables declared like this
// will be stored in the window object. This is very unclean and needs to be avoided.
console.log(window.x + &apos; &apos; + window.y);
</code></pre><p>推荐</p>
<pre><code>// We declare a IIFE and pass parameters into the function that we will use from the global space
(function(log, w, undefined){
  &apos;use strict&apos;;

  var x = 10,
      y = 100;

  // Will output &apos;true true&apos;
  log((w.x === undefined) + &apos; &apos; + (w.y === undefined));

}(window.console.log, window));
</code></pre><p>##IIFE（立即执行的函数表达式）</p>
<p>无论何时，想要创建一个新的封闭的定义域，那就用 IIFE。它不仅避免了干扰，也使得内存在执行完后立即释放。</p>
<p>所有脚本文件建议都从 IIFE 开始。</p>
<p>立即执行的函数表达式的执行括号应该写在外包括号内。虽然写在内还是写在外都是有效的，但写在内使得整个表达式看起来更像一个整体，因此推荐这么做。</p>
<p>不推荐</p>
<pre><code>(function(){})();
</code></pre><p>推荐</p>
<pre><code>(function(){}());
</code></pre><p>so，用下列写法来格式化你的 IIFE 代码：</p>
<pre><code>(function(){
  &apos;use strict&apos;;

  // Code goes here

}());
</code></pre><p>如果你想引用全局变量或者是外层 IIFE 的变量，可以通过下列方式传参：</p>
<pre><code>(function($, w, d){
  &apos;use strict&apos;;

  $(function() {
    w.alert(d.querySelectorAll(&apos;div&apos;).length);
  });
}(jQuery, window, document));
</code></pre><p>严格模式</p>
<p>ECMAScript 5 严格模式可在整个脚本或独个方法内被激活。它对应不同的 javascript 语境会做更加严格的错误检查。严格模式也确保了 javascript 代码更加的健壮，运行的也更加快速。</p>
<p>严格模式会阻止使用在未来很可能被引入的预留关键字。</p>
<p>你应该在你的脚本中启用严格模式，最好是在独立的 IIFE 中应用它。避免在你的脚本第一行使用它而导致你的所有脚本都启动了严格模式，这有可能会引发一些第三方类库的问题。</p>
<p>不推荐</p>
<pre><code>// Script starts here
&apos;use strict&apos;;

(function(){

  // Your code starts here

}());
</code></pre><p>推荐</p>
<pre><code>(function(){
  &apos;use strict&apos;;

  // Your code starts here

}());
</code></pre><p>##变量声明</p>
<p>总是使用 var 来声明变量。如不指定 var，变量将被隐式地声明为全局变量，这将对变量难以控制。如果没有声明，变量处于什么定义域就变得不清（可以是在 Document 或 Window 中，也可以很容易地进入本地定义域）。所以，请总是使用 var 来声明变量。</p>
<p>采用严格模式带来的好处是，当你手误输入错误的变量名时，它可以通过报错信息来帮助你定位错误出处。</p>
<p>不推荐</p>
<pre><code>x = 10;
y = 100;
</code></pre><p>推荐</p>
<pre><code>var x = 10,
    y = 100;
</code></pre><p>##理解 JavaScript 的定义域和定义域提升</p>
<p>在 JavaScript 中变量和方法定义会自动提升到执行之前。JavaScript 只有 function 级的定义域，而无其他很多编程语言中的块定义域，所以使得你在某一 function 内的某语句和循环体中定义了一个变量，此变量可作用于整个 function 内，而不仅仅是在此语句或循环体中，因为它们的声明被 JavaScript 自动提升了。</p>
<p>我们通过例子来看清楚这到底是怎么一回事：</p>
<p>原 function</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  var a = 10;

  for(var i = 0; i &lt; a; i++) {
    var b = i * i;
    log(b);
  }

  if(a === 10) {
    var f = function() {
      log(a);
    };
    f();
  }

  function x() {
    log(&apos;Mr. X!&apos;);
  }
  x();

}(window.console.log));
</code></pre><p>被 JS 提升过后</p>
<pre><code>(function(log){
  &apos;use strict&apos;;
  // All variables used in the closure will be hoisted to the top of the function
  var a,
      i,
      b,
      f;
  // All functions in the closure will be hoisted to the top
  function x() {
    log(&apos;Mr. X!&apos;);
  }

  a = 10;

  for(i = 0; i &lt; a; i++) {
    b = i * i;
    log(b);
  }

  if(a === 10) {
    // Function assignments will only result in hoisted variables but the function body will not be hoisted
    // Only by using a real function declaration the whole function will be hoisted with its body
    f = function() {
      log(a);
    };
    f();
  }

  x();

}(window.console.log));    
</code></pre><p>根据以上提升过程，你是否可理解以下代码？</p>
<p>有效代码</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  var a = 10;

  i = 5;

  x();

  for(var i; i &lt; a; i++) {
    log(b);
    var b = i * i;
  }

  if(a === 10) {
    f = function() {
          log(a);
    };
    f();

    var f;
  }

  function x() {
    log(&apos;Mr. X!&apos;);
  }

}(window.console.log));
</code></pre><p>正如你所看到的这段令人充满困惑与误解的代码导致了出人意料的结果。只有良好的声明习惯，也就是下一章节我们要提到的声明规则，才能尽可能的避免这类错误风险。</p>
<p>##提升声明</p>
<p>为避免上一章节所述的变量和方法定义被自动提升造成误解，把风险降到最低，我们应该手动地显示地去声明变量与方法。也就是说，所有的变量以及方法，应当定义在 function 内的首行。</p>
<p>只用一个 var 关键字声明，多个变量用逗号隔开。</p>
<p>不推荐</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  var a = 10;
  var b = 10;

  for(var i = 0; i &lt; 10; i++) {
    var c = a * b * i;
  }

  function f() {

  }

  var d = 100;
  var x = function() {
    return d * d;
  };
  log(x());

}(window.console.log));
</code></pre><p>推荐</p>
<p>(function(log){<br>  ‘use strict’;</p>
<p>  var a = 10,<br>      b = 10,<br>      i,<br>      c,<br>      d,<br>      x;</p>
<p>  function f() {</p>
<p>  }</p>
<p>  for(i = 0; i &lt; 10; i++) {<br>    c = a <em> b </em> i;<br>  }</p>
<p>  d = 100;<br>  x = function() {<br>    return d * d;<br>  };<br>  log(x());</p>
<p>}(window.console.log));</p>
<p>把赋值尽量写在变量申明中。</p>
<p>不推荐</p>
<pre><code>var a,
    b,
    c;

a = 10;
b = 10;
c = 100;
</code></pre><p>推荐</p>
<pre><code>var a = 10,
    b = 10,
    c = 100;
</code></pre><p>##总是使用带类型判断的比较判断</p>
<p>总是使用 === 精确的比较操作符，避免在判断的过程中，由 JavaScript 的强制类型转换所造成的困扰。</p>
<p>如果你使用 === 操作符，那比较的双方必须是同一类型为前提的条件下才会有效。</p>
<p>如果你想了解更多关于强制类型转换的信息，你可以读一读 Dmitry Soshnikov 的这篇文章。</p>
<p>在只使用 == 的情况下，JavaScript 所带来的强制类型转换使得判断结果跟踪变得复杂，下面的例子可以看出这样的结果有多怪了：</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  log(&apos;0&apos; == 0); // true
  log(&apos;&apos; == false); // true
  log(&apos;1&apos; == true); // true
  log(null == undefined); // true

  var x = {
    valueOf: function() {
      return &apos;X&apos;;
    }
  };

  log(x == &apos;X&apos;);

}(window.console.log));
</code></pre><p>##明智地使用真假判断</p>
<p>当我们在一个 if 条件语句中使用变量或表达式时，会做真假判断。if(a == true) 是不同于 if(a) 的。后者的判断比较特殊，我们称其为真假判断。这种判断会通过特殊的操作将其转换为 true 或 false，下列表达式统统返回 false：false, 0, undefined, null, NaN, ‘’（空字符串）.</p>
<p>这种真假判断在我们只求结果而不关心过程的情况下，非常的有帮助。</p>
<p>以下示例展示了真假判断是如何工作的：</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  function logTruthyFalsy(expr) {
    if(expr) {
      log(&apos;truthy&apos;);
    } else {
      log(&apos;falsy&apos;);
    }
  }

  logTruthyFalsy(true); // truthy
  logTruthyFalsy(1); // truthy
  logTruthyFalsy({}); // truthy
  logTruthyFalsy([]); // truthy
  logTruthyFalsy(&apos;0&apos;); // truthy

  logTruthyFalsy(false); // falsy
  logTruthyFalsy(0); // falsy
  logTruthyFalsy(undefined); // falsy
  logTruthyFalsy(null); // falsy
  logTruthyFalsy(NaN); // falsy
  logTruthyFalsy(&apos;&apos;); // falsy

}(window.console.log));
</code></pre><p>##变量赋值时的逻辑操作</p>
<p>逻辑操作符 || 和 &amp;&amp; 也可被用来返回布尔值。如果操作对象为非布尔对象，那每个表达式将会被自左向右地做真假判断。基于此操作，最终总有一个表达式被返回回来。这在变量赋值时，是可以用来简化你的代码的。</p>
<p>不推荐</p>
<pre><code>if(!x) {
  if(!y) {
    x = 1;
  } else {
    x = y;
  }
}
</code></pre><p>推荐</p>
<pre><code>x = x || y || 1;
</code></pre><p>这一小技巧经常用来给方法设定默认的参数。</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  function multiply(a, b) {
    a = a || 1;
    b = b || 1;

    log(&apos;Result &apos; + a * b);
  }

  multiply(); // Result 1
  multiply(10); // Result 10
  multiply(3, NaN); // Result 3
  multiply(9, 5); // Result 45

}(window.console.log));
</code></pre><p>##分号</p>
<p>总是使用分号，因为隐式的代码嵌套会引发难以察觉的问题。当然我们更要从根本上来杜绝这些问题<a href="作者指的是采用严格规范的语句写法，从根本上杜绝由分号缺失而引起的代码歧义。">^1</a> 。以下几个示例展示了缺少分号的危害：</p>
<pre><code>// 1.
MyClass.prototype.myMethod = function() {
  return 42;
}  // No semicolon here.

(function() {
  // Some initialization code wrapped in a function to create a scope for locals.
})();


var x = {
  &apos;i&apos;: 1,
  &apos;j&apos;: 2
}  // No semicolon here.

// 2.  Trying to do one thing on Internet Explorer and another on Firefox.
// I know you&apos;d never write code like this, but throw me a bone.
[ffVersion, ieVersion][isIE]();


var THINGS_TO_EAT = [apples, oysters, sprayOnCheese]  // No semicolon here.

// 3. conditional execution a la bash
-1 == resultOfOperation() || die();
</code></pre><p>So what happens?</p>
<ol>
<li>JavaScript 错误 —— 首先返回 42 的那个 function 被第二个 function 当中参数传入调用，接着数字 42 也被“调用”而导致出错。</li>
<li>八成你会得到 ‘no such property in undefined’ 的错误提示，因为在真实环境中的调用是这个样子：x[ffVersion, ieVersion]<a href="">isIE</a>.</li>
<li>die 总是被调用。因为数组减 1 的结果是 NaN，它不等于任何东西（无论 resultOfOperation 是否返回 NaN）。所以最终的结果是 die() 执行完所获得值将赋给 THINGS_TO_EAT.</li>
</ol>
<p>Why?</p>
<p>JavaScript 中语句要以分号结束，否则它将会继续执行下去，不管换不换行。以上的每一个示例中，函数声明或对象或数组，都变成了在一句语句体内。要知道闭合圆括号并不代表语句结束，JavaScript 不会终结语句，除非它的下一个 token 是一个中缀符[^2] 或者是圆括号操作符。</p>
<p>这真是让人大吃一惊，所以乖乖地给语句末加上分号吧。</p>
<p><strong>澄清：分号与函数</strong></p>
<p>分号需要用在表达式的结尾，而并非函数声明的结尾。区分它们最好的例子是：</p>
<pre><code>var foo = function() {
  return true;
};  // semicolon here.

function foo() {
  return true;
}  // no semicolon here.
</code></pre><p>##嵌套函数</p>
<p>嵌套函数是非常有用的，比如用在持续创建和隐藏辅助函数的任务中。你可以非常自由随意地使用它们。</p>
<p>##语句块内的函数声明</p>
<p>切勿在语句块内声明函数，在 ECMAScript 5 的严格模式下，这是不合法的。函数声明应该在定义域的顶层。但在语句块内可将函数申明转化为函数表达式赋值给变量。</p>
<p>不推荐</p>
<pre><code>if (x) {
  function foo() {}
}
</code></pre><p>推荐</p>
<pre><code>if (x) {
  var foo = function() {};
}
</code></pre><p>##异常</p>
<p>基本上你无法避免出现异常，特别是在做大型开发时（使用应用开发框架等等）。</p>
<p>在没有自定义异常的情况下，从有返回值的函数中返回错误信息一定非常的棘手，更别提多不优雅了。不好的解决方案包括了传第一个引用类型来接纳错误信息，或总是返回一个对象列表，其中包含着可能的错误对象。以上方式基本上是比较简陋的异常处理方式。适时可做自定义异常处理。</p>
<p>在复杂的环境中，你可以考虑抛出对象而不仅仅是字符串（默认的抛出值）。</p>
<pre><code>if(name === undefined) {
  throw {
    name: &apos;System Error&apos;,
    message: &apos;A name should always be specified!&apos;
  }
}
</code></pre><p>##标准特性</p>
<p>总是优先考虑使用标准特性。为了最大限度地保证扩展性与兼容性，总是首选标准的特性，而不是非标准的特性（例如：首选 string.charAt(3) 而不是 string[3]；首选 DOM 的操作方法来获得元素引用，而不是某一应用特定的快捷方法）。</p>
<p>##简易的原型继承</p>
<p>如果你想在 JavaScript 中继承你的对象，请遵循一个简易的模式来创建此继承。如果你预计你会遇上复杂对象的继承，那可以考虑采用一个继承库，比如 Proto.js by Axel Rauschmayer.</p>
<p>简易继承请用以下方式：</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  // Constructor function
  function Apple(name) {
    this.name = name;
  }
  // Defining a method of apple
  Apple.prototype.eat = function() {
    log(&apos;Eating &apos; + this.name);
  };

  // Constructor function
  function GrannySmithApple() {
    // Invoking parent constructor
    Apple.prototype.constructor.call(this, &apos;Granny Smith&apos;);
  }
  // Set parent prototype while creating a copy with Object.create
  GrannySmithApple.prototype = Object.create(Apple.prototype);
  // Set constructor to the sub type, otherwise points to Apple
  GrannySmithApple.prototype.constructor = GrannySmithApple;

      // Calling a super method
      GrannySmithApple.prototype.eat = function() {
    // Be sure to apply it onto our current object with call(this)
    Apple.prototype.eat.call(this);

    log(&apos;Poor Grany Smith&apos;);
  };

  // Instantiation
  var apple = new Apple(&apos;Test Apple&apos;);
  var grannyApple = new GrannySmithApple();

  log(apple.name); // Test Apple
  log(grannyApple.name); // Granny Smith

  // Instance checks
  log(apple instanceof Apple); // true
  log(apple instanceof GrannySmithApple); // false

  log(grannyApple instanceof Apple); // true
  log(grannyApple instanceof GrannySmithApple); // true

  // Calling method that calls super method
  grannyApple.eat(); // Eating Granny Smith\nPoor Grany Smith

}(window.console.log));
</code></pre><p>##使用闭包</p>
<p>闭包的创建也许是 JS 最有用也是最易被忽略的能力了。<a href="http://jibbering.com/faq/faq_notes/closures.html" target="_blank" rel="external">关于闭包如何工作的合理解释</a>。</p>
<p>##切勿在循环中创建函数</p>
<p>在简单的循环语句中加入函数是非常容易形成闭包而带来隐患的。下面的例子就是一个典型的陷阱：</p>
<p>不推荐</p>
<pre><code>(function(log, w){
  &apos;use strict&apos;;

  // numbers and i is defined in the current function closure
  var numbers = [1, 2, 3],
      i;

  for(i = 0; i &lt; numbers.length; i++) {
    w.setTimeout(function() {
      // At the moment when this gets executed the i variable, coming from the outer function scope
      // is set to 3 and the current program is alerting the message 3 times
      // &apos;Index 3 with number undefined
      // If you understand closures in javascript you know how to deal with those cases
      // It&apos;s best to just avoid functions / new closures in loops as this prevents those issues

      w.alert(&apos;Index &apos; + i + &apos; with number &apos; + numbers[i]);
    }, 0);
  }

}(window.console.log, window));
</code></pre><p>接下来的改进虽然已经解决了上述例子中的问题或 bug，但还是违反了不在循环中创建函数或闭包的原则。</p>
<p>不推荐</p>
<pre><code>(function(log, w){
  &apos;use strict&apos;;

  // numbers and i is defined in the current function closure
  var numbers = [1, 2, 3],
      i;

  for(i = 0; i &lt; numbers.length; i++) {
    // Creating a new closure scope with an IIFE solves the problem
    // The delayed function will use index and number which are
    // in their own closure scope (one closure per loop iteration).
    // ---
    // Still this is not recommended as we violate our rule to not
    // create functions within loops and we are creating two!

    (function(index, number){
      w.setTimeout(function() {
        // Will output as expected 0 &gt; 1, 1 &gt; 2, 2 &gt; 3
        w.alert(&apos;Index &apos; + index + &apos; with number &apos; + number);
      }, 0);
    }(i, numbers[i]));
  }

}(window.console.log, window));
</code></pre><p>接下来的改进已解决问题，而且也遵循了规范。可是，你会发现看上去似乎过于复杂繁冗了，应该会有更好的解决方案吧。</p>
<p>不完全推荐</p>
<pre><code>(function(log, w){
  &apos;use strict&apos;;

  // numbers and i is defined in the current function closure
  var numbers = [1, 2, 3],
      i;

  // Create a function outside of the loop that will accept arguments to create a
  // function closure scope. This function will return a function that executes in this
  // closure parent scope.
  function alertIndexWithNumber(index, number) {
    return function() {
      w.alert(&apos;Index &apos; + index + &apos; with number &apos; + number);
    };
  }

  // First parameter is a function call that returns a function.
  // ---
  // This solves our problem and we don&apos;t create a function inside our loop
  for(i = 0; i &lt; numbers.length; i++) {
    w.setTimeout(alertIndexWithNumber(i, numbers[i]), 0);
  }

}(window.console.log, window));
</code></pre><p>将循环语句转换为函数执行的方式问题能得到立马解决，每一次循环都会对应地创建一次闭包。函数式的风格更加值得推荐，而且看上去也更加地自然和可预料。</p>
<p>推荐</p>
<pre><code>(function(log, w){
  &apos;use strict&apos;;

  // numbers and i is defined in the current function closure
  var numbers = [1, 2, 3],
      i;

  numbers.forEach(function(number, index) {
    w.setTimeout(function() {
      w.alert(&apos;Index &apos; + index + &apos; with number &apos; + number);
    }, 0);
  });

}(window.console.log, window));
</code></pre><p>eval 函数（魔鬼）</p>
<p>eval() 不但混淆语境还很危险，总会有比这更好、更清晰、更安全的另一种方案来写你的代码，因此尽量不要使用 evil 函数。</p>
<p>this 关键字</p>
<p>只在对象构造器、方法和在设定的闭包中使用 this 关键字。this 的语义在此有些误导。它时而指向全局对象（大多数时），时而指向调用者的定义域（在 eval 中），时而指向 DOM 树中的某一节点（当用事件处理绑定到 HTML 属性上时），时而指向一个新创建的对象（在构造器中），还时而指向其它的一些对象（如果函数被 call() 和 apply() 执行和调用时）。</p>
<p>正因为它是如此容易地被搞错，请限制它的使用场景：</p>
<ul>
<li>在构造函数中</li>
<li>在对象的方法中（包括由此创建出的闭包内）</li>
</ul>
<p>##首选函数式风格</p>
<p>函数式编程让你可以简化代码并缩减维护成本，因为它容易复用，又适当地解耦和更少的依赖。</p>
<p>接下来的例子中，在一组数字求和的同一问题上，比较了两种解决方案。第一个例子是经典的程序处理，而第二个例子则是采用了函数式编程和 ECMA Script 5.1 的数组方法。</p>
<p>例外：往往在重代码性能轻代码维护的情况之下，要选择最优性能的解决方案而非维护性高的方案（比如用简单的循环语句代替 forEach）。</p>
<p>不推荐</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  var arr = [10, 3, 7, 9, 100, 20],
      sum = 0,
      i;


  for(i = 0; i &lt; arr.length; i++) {
    sum += arr[i];
  }

  log(&apos;The sum of array &apos; + arr + &apos; is: &apos; + sum)

}(window.console.log));
</code></pre><p>推荐</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  var arr = [10, 3, 7, 9, 100, 20];

  var sum = arr.reduce(function(prevValue, currentValue) {
    return prevValue + currentValue;
  }, 0);

  log(&apos;The sum of array &apos; + arr + &apos; is: &apos; + sum);

}(window.console.log));
</code></pre><p>另一个例子通过某一规则对一个数组进行过滤匹配来创建一个新的数组。</p>
<p>不推荐</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  var numbers = [11, 3, 7, 9, 100, 20, 14, 10],
      numbersGreaterTen = [],
      i;


  for(i = 0; i &lt; numbers.length; i++) {
    if(numbers[i] &gt; 10) {
      numbersGreaterTen.push(numbers[i]);
    }
  }

  log(&apos;From the list of numbers &apos; + numbers + &apos; only &apos; + numbersGreaterTen + &apos; are greater than ten&apos;);

}(window.console.log));
</code></pre><p>推荐</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  var numbers = [11, 3, 7, 9, 100, 20, 14, 10];

  var numbersGreaterTen = numbers.filter(function(element) {
    return element &gt; 10;
  });

  log(&apos;From the list of numbers &apos; + numbers + &apos; only &apos; + numbersGreaterTen + &apos; are greater than ten&apos;);

}(window.console.log));
</code></pre><p>##使用 ECMA Script 5</p>
<p>建议使用 ECMA Script 5 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p>
<p>##数组和对象的属性迭代</p>
<p>用 ECMA5 的迭代方法来迭代数组。使用 Array.forEach 或者如果你要在特殊场合下中断迭代，那就用 Array.every。</p>
<pre><code>(function(log){
  &apos;use strict&apos;;

  // Iterate over an array and break at a certain condition
  [1, 2, 3, 4, 5].every(function(element, index, arr) {
    log(element + &apos; at index &apos; + index + &apos; in array &apos; + arr);

    if(index !== 5) {
      return true;
    }
  });

  // Defining a simple javascript object
  var obj = {
    a: &apos;A&apos;,
    b: &apos;B&apos;,
    &apos;c-d-e&apos;: &apos;CDE&apos;
  };

  // Iterating over the object keys
  Object.keys(obj).forEach(function(element, index, arr) {
    log(&apos;Key &apos; + element + &apos; has value &apos; + obj[element]);
  });

}(window.console.log));
</code></pre><p>##不要使用 switch</p>
<p>switch 在所有的编程语言中都是个非常错误的难以控制的语句，建议用 if else 来替换它。 </p>
<p>##数组和对象字面量</p>
<p>用数组和对象字面量来代替数组和对象构造器。数组构造器很容易让人在它的参数上犯错。</p>
<p>不推荐</p>
<pre><code>// Length is 3.
var a1 = new Array(x1, x2, x3);

// Length is 2.
var a2 = new Array(x1, x2);

// If x1 is a number and it is a natural number the length will be x1.
// If x1 is a number but not a natural number this will throw an exception.
// Otherwise the array will have one element with x1 as its value.
var a3 = new Array(x1);

// Length is 0.
var a4 = new Array();
</code></pre><p>正因如此，如果将代码传参从两个变为一个，那数组很有可能发生意料不到的长度变化。为避免此类怪异状况，请总是采用更多可读的数组字面量。</p>
<p>推荐   </p>
<pre><code>var a = [x1, x2, x3];
var a2 = [x1, x2];
var a3 = [x1];
var a4 = [];
</code></pre><p>对象构造器不会有类似的问题，但是为了可读性和统一性，我们应该使用对象字面量。</p>
<p>不推荐</p>
<pre><code>var o = new Object();

var o2 = new Object();
o2.a = 0;
o2.b = 1;
o2.c = 2;
o2[&apos;strange key&apos;] = 3;
</code></pre><p>应该写成这样：</p>
<p>推荐   </p>
<pre><code>var o = {};

var o2 = {
    a: 0,
    b: 1,
    c: 2,
    &apos;strange key&apos;: 3
};
</code></pre><p>##修改内建对象的原型链</p>
<p>修改内建的诸如 Object.prototype 和 Array.prototype 是被严厉禁止的。修改其它的内建对象比如 Function.prototype，虽危害没那么大，但始终还是会导致在开发过程中难以 debug 的问题，应当也要避免。</p>
<p>##自定义 toString() 方法</p>
<p>你可以通过自定义 toString() 来控制对象字符串化。这很好，但你必须保证你的方法总是成功并不会有其它副作用。如果你的方法达不到这样的标准，那将会引发严重的问题。如果 toString() 调用了一个方法，这个方法做了一个断言[^3] ，当断言失败，它可能会输出它所在对象的名称，当然对象也需要调用 toString()。</p>
<p>##圆括号</p>
<p>一般在语法和语义上真正需要时才谨慎地使用圆括号。不要用在一元操作符上，例如 delete, typeof 和 void，或在关键字之后，例如 return, throw, case, new 等。</p>
<p>##字符串</p>
<p>统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：</p>
<pre><code>var msg = &apos;This is some HTML &lt;div class=&quot;makes-sense&quot;&gt;&lt;/div&gt;&apos;;
</code></pre><p>##三元条件判断（if 的快捷方法）  </p>
<p>用三元操作符分配或返回语句。在比较简单的情况下使用，避免在复杂的情况下使用。没人愿意用 10 行三元操作符把自己的脑子绕晕。</p>
<p>不推荐</p>
<pre><code>if(x === 10) {
  return &apos;valid&apos;;
} else {
  return &apos;invalid&apos;;
}
</code></pre><p>推荐</p>
<pre><code>return x === 10 ? &apos;valid&apos; : &apos;invalid&apos;;
</code></pre><p>[^2]:中缀符，指的是像 x + y 中的 +。</p>
<p>[^3]:断言一般指程序员在测试测序时的假设，一般是一些布尔表达式，当返回是 true 时，断言为真，代码运行会继续进行；如果条件判断为 false，代码运行停止，你的应用被终止。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/01/2017-3-9/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Rufer">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Rufer's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Rufer's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/2017-3-9/" itemprop="url">
                  前端代码规范-html
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T23:40:02+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/2017-3-9/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/01/2017-3-9/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##文档类型</p>
<p>推荐使用 HTML5 的文档类型申明： &lt;!DOCTYPE html&gt;.</p>
<p>（建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p>
<p>HTML 中最好不要将无内容元素[^1] 的标签闭合，例如：使用 <br> 而非 <br>.</p>
<p>##HTML 验证</p>
<p>一般情况下，建议使用能通过标准规范验证的 HTML 代码，除非在性能优化和控制文件大小上不得不做出让步。</p>
<p>使用诸如 W3C HTML validator 这样的工具来进行检测。</p>
<p>规范化的 HTML 是显现技术要求与局限的显著质量基线，它促进了 HTML 被更好地运用。</p>
<p>不推荐</p>
<pre><code>&lt;title&gt;Test&lt;/title&gt;
&lt;article&gt;This is only a test.
</code></pre><p>推荐</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Test&lt;/title&gt;
&lt;article&gt;This is only a test.&lt;/article&gt;
</code></pre><p>##省略可选标签</p>
<p>HTML5 规范中规定了 HTML 标签是可以省略的。但从可读性来说，在开发的源文件中最好不要这样做，因为省略标签可能会导致一些问题。</p>
<p>省略一些可选的标签确实使得页面大小减少，这很有用，尤其是对于一些大型网站来说。为了达到这一目的，我们可以在开发后期对页面进行压缩处理，在这个环节中这些可选的标签完全就可以省略掉了。</p>
<p>##脚本加载</p>
<p>出于性能考虑，脚本异步加载很关键。一段脚本放置在 <head> 内，比如 <script src="main.js"></script>，其加载会一直阻塞 DOM 解析，直至它完全地加载和执行完毕。这会造成页面显示的延迟。特别是一些重量级的脚本，对用户体验来说那真是一个巨大的影响。</head></p>
<p>异步加载脚本可缓解这种性能影响。如果只需兼容 IE10+，可将 HTML5 的 async 属性加至脚本中，它可防止阻塞 DOM 的解析，甚至你可以将脚本引用写在 <head> 里也没有影响。</head></p>
<p>如需兼容老旧的浏览器，实践表明可使用用来动态注入脚本的脚本加载器。你可以考虑 yepnope 或 labjs。注入脚本的一个问题是：一直要等到 CSS 对象文档已就绪，它们才开始加载（短暂地在 CSS 加载完毕之后），这就对需要及时触发的 JS 造成了一定的延迟，这多多少少也影响了用户体验吧。</p>
<p>终上所述，兼容老旧浏览器(IE9-)时，应该遵循以下最佳实践。</p>
<p>脚本引用写在 body 结束标签之前，并带上 async 属性。这虽然在老旧浏览器中不会异步加载脚本，但它只阻塞了 body 结束标签之前的 DOM 解析，这就大大降低了其阻塞影响。而在现代浏览器中，脚本将在 DOM 解析器发现 body 尾部的 script 标签才进行加载，此时加载属于异步加载，不会阻塞 CSSOM（但其执行仍发生在 CSSOM 之后）。</p>
<p>所有浏览器中，推荐</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- body goes here --&gt;

    &lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>只在现代浏览器中，推荐</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt;
    &lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- body goes here --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>##语义化</p>
<p>根据元素（有时被错误地称作“标签”）其被创造出来时的初始意义来使用它。打个比方，用 heading 元素来定义头部标题，p 元素来定义文字段落，用 a 元素来定义链接锚点，等等。</p>
<p>有根据有目的地使用 HTML 元素，对于可访问性、代码重用、代码效率来说意义重大。</p>
<p>以下示例列出了一些的语义化 HTML 主要情况：</p>
<p>不推荐</p>
<pre><code>&lt;b&gt;My page title&lt;/b&gt;
&lt;div class=&quot;top-navigation&quot;&gt;
    &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;news-page&quot;&gt;
    &lt;div class=&quot;page-section news&quot;&gt;
        &lt;div class=&quot;title&quot;&gt;All news articles&lt;/div&gt;
        &lt;div class=&quot;news-article&quot;&gt;
        &lt;h2&gt;Bad article&lt;/h2&gt;
        &lt;div class=&quot;intro&quot;&gt;Introduction sub-title&lt;/div&gt;
        &lt;div class=&quot;content&quot;&gt;This is a very bad example for HTML semantics&lt;/div&gt;
        &lt;div class=&quot;article-side-notes&quot;&gt;I think I&apos;m more on the side and should not receive the main credits&lt;/div&gt;
        &lt;div class=&quot;article-foot-notes&quot;&gt;
            This article was created by David &lt;div class=&quot;time&quot;&gt;2014-01-01 00:00&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

     &lt;div class=&quot;section-footer&quot;&gt;
            Related sections: Events, Public holidays
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;page-footer&quot;&gt;
    Copyright 2014
&lt;/div&gt;
</code></pre><p>推荐<br>    <!-- The page header should go into a header element --><br>    <header><br>      <!-- As this title belongs to the page structure it's a heading and h1 should be used --><br>      <h1>My page title</h1><br>    </header></p>
<pre><code>&lt;!-- All navigation should go into a nav element --&gt;
&lt;nav class=&quot;top-navigation&quot;&gt;
  &lt;!-- A listing of elements should always go to UL (OL for ordered listings) --&gt;
  &lt;ul&gt;
    &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;!-- The main part of the page should go into a main element (also use role=&quot;main&quot; for accessibility) --&gt;
&lt;main class=&quot;news-page&quot; role=&quot;main&quot;&gt;
  &lt;!-- A section of a page should go into a section element. Divide a page into sections with semantic elements. --&gt;
  &lt;section class=&quot;page-section news&quot;&gt;
    &lt;!-- A section header should go into a section element --&gt;
    &lt;header&gt;
      &lt;!-- As a page section belongs to the page structure heading elements should be used (in this case h2) --&gt;
      &lt;h2 class=&quot;title&quot;&gt;All news articles&lt;/h2&gt;
    &lt;/header&gt;

    &lt;!-- If a section / module can be seen as an article (news article, blog entry, products teaser, any other
     re-usable module / section that can occur multiple times on a page) a article element should be used --&gt;
    &lt;article class=&quot;news-article&quot;&gt;
      &lt;!-- An article can contain a header that contains the summary / introduction information of the article --&gt;
      &lt;header&gt;
        &lt;!-- As a article title does not belong to the overall page structure there should not be any heading tag! --&gt;
        &lt;div class=&quot;article-title&quot;&gt;Good article&lt;/div&gt;
        &lt;!-- Small can optionally be used to reduce importance --&gt;
        &lt;small class=&quot;intro&quot;&gt;Introduction sub-title&lt;/small&gt;
      &lt;/header&gt;

      &lt;!-- For the main content in a section or article there is no semantic element --&gt;
      &lt;div class=&quot;content&quot;&gt;
        &lt;p&gt;This is a good example for HTML semantics&lt;/p&gt;
      &lt;/div&gt;
      &lt;!-- For content that is represented as side note or less important information in a given context use aside --&gt;
      &lt;aside class=&quot;article-side-notes&quot;&gt;
        &lt;p&gt;I think I&apos;m more on the side and should not receive the main credits&lt;/p&gt;
      &lt;/aside&gt;
      &lt;!-- Articles can also contain footers. If you have footnotes for an article place them into a footer element --&gt;
      &lt;footer class=&quot;article-foot-notes&quot;&gt;
        &lt;!-- The time element can be used to annotate a timestamp. Use the datetime attribute to specify ISO time
         while the actual text in the time element can also be more human readable / relative --&gt;
        &lt;p&gt;This article was created by David &lt;time datetime=&quot;2014-01-01 00:00&quot; class=&quot;time&quot;&gt;1 month ago&lt;/time&gt;&lt;/p&gt;
      &lt;/footer&gt;
    &lt;/article&gt;

    &lt;!-- In a section, footnotes or similar information can also go into a footer element --&gt;
    &lt;footer class=&quot;section-footer&quot;&gt;
      &lt;p&gt;Related sections: Events, Public holidays&lt;/p&gt;
    &lt;/footer&gt;
  &lt;/section&gt;
&lt;/main&gt;

&lt;!-- Your page footer should go into a global footer element --&gt;
&lt;footer class=&quot;page-footer&quot;&gt;
  Copyright 2014
&lt;/footer&gt;
</code></pre><p>##多媒体回溯</p>
<p>对页面上的媒体而言，像图片、视频、canvas 动画等，要确保其有可替代的接入接口。图片文件我们可采用有意义的备选文本（alt），视频和音频文件我们可以为其加上说明文字或字幕。</p>
<p>提供可替代内容对可用性来说十分重要。试想，一位盲人用户如何能知晓一张图片是什么，要是没有 @alt 的话。</p>
<p>（图片的 alt 属性是可不填写内容的，纯装饰性的图片就可用这么做：alt=””）。</p>
<p>不推荐</p>
<pre><code>&lt;img src=&quot;luke-skywalker.jpg&quot;&gt;
</code></pre><p>推荐</p>
<pre><code>&lt;img src=&quot;luke-skywalker.jpg&quot; alt=&quot;Luke skywalker riding an alien horse&quot;&gt;
</code></pre><p>尽量用 alt 标签去描述图片，设想你需要对于那些只能通过语音或者看不见图片的用户表达图片到底是什么。</p>
<p>不推荐</p>
<pre><code>&lt;img src=&quot;huge-spaceship-approaching-earth.jpg&quot; alt=&quot;Header image&quot;&gt;
</code></pre><p>推荐</p>
<pre><code>&lt;img src=&quot;huge-spaceship-approaching-earth.jpg&quot; alt=&quot;A huge spaceship that is approaching the earth&quot;&gt;
</code></pre><p>##关注点分离</p>
<p>理解 web 中如何和为何区分不同的关注点，这很重要。这里的关注点主要指的是：信息（HTML 结构）、外观（CSS）和行为（JavaScript）。为了使它们成为可维护的干净整洁的代码，我们要尽可能的将它们分离开来。</p>
<p>严格地保证结构、表现、行为三者分离，并尽量使三者之间没有太多的交互和联系。</p>
<p>就是说，尽量在文档和模板中只包含结构性的 HTML；而将所有表现代码，移入样式表中；将所有动作行为，移入脚本之中。</p>
<p>在此之外，为使得它们之间的联系尽可能的小，在文档和模板中也尽量少地引入样式和脚本文件。</p>
<p>清晰的分层意味着：</p>
<ul>
<li>超过一到两张样式表（i.e. main.css, vendor.css）</li>
<li>用超过一到两个脚本（学会用合并脚本）</li>
<li>用行内样式（<style>.no-good {}</style>）</li>
<li>元素上使用 style 属性（<hr style="border-top: 5px solid black">）</li>
<li>用行内脚本（<script>alert(‘no good’)</script>）</li>
<li>用表象元素（i.e. <b>, <u>, <center>, <font>, <b>）</b></font></center></u></b></li>
<li>用表象 class 名（i.e. red, left, center）</li>
</ul>
<p>不推荐</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;base.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;grid.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;type.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;modules/teaser.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 style=&quot;font-size: 3rem&quot;&gt;&lt;/h1&gt;
  &lt;b&gt;I&apos;m a subtitle and I&apos;m bold!&lt;/b&gt;
  &lt;center&gt;Dare you center me!&lt;/center&gt;
  &lt;script&gt;
    alert(&apos;Just dont...&apos;);
  &lt;/script&gt;
  &lt;div class=&quot;red&quot;&gt;I&apos;m important!&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>推荐</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;!-- Concatinate your style sheets into a single one --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- Don&apos;t use style attributes but assign sensible classes and apply styles in the stylesheet --&gt;
  &lt;h1 class=&quot;title&quot;&gt;&lt;/h1&gt;
  &lt;!-- Don&apos;t use presentational elements and assign sensible classes --&gt;
  &lt;div class=&quot;sub-title&quot;&gt;I&apos;m a subtitle and I&apos;m bold!&lt;/div&gt;
  &lt;!-- Maybe your comments get centered in your presentation but that decision is up to the stylesheet --&gt;
  &lt;span class=&quot;comment&quot;&gt;Dare you center me!&lt;/span&gt;
  &lt;!-- You wanted to make it red because it&apos;s important so then also name the class important and decide in the stylesheet
   what you want to do with it --&gt;
  &lt;div class=&quot;important&quot;&gt;I&apos;m important!&lt;/div&gt;

  &lt;!-- Put all your scripts into files and concatinate them into a single one --&gt;
  &lt;script async src=&quot;main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>##HTML内容至上</p>
<p>不要让非内容信息污染了你的 HTML。现在貌似有一种倾向：通过 HTML 来解决设计问题，这是显然是不对的。HTML 就应该只关注内容。</p>
<p>HTML 标签的目的，就是为了不断地展示内容信息。</p>
<ul>
<li>引入一些特定的 HTML 结构来解决一些视觉设计问题</li>
<li>将 img 元素当做专门用来做视觉设计的元素</li>
</ul>
<p>以下例子展示了误将 HTML 用来解决设计问题的这两种情况：</p>
<p>不推荐</p>
<pre><code>&lt;!-- We should not introduce an additional element just to solve a design problem  --&gt;
&lt;span class=&quot;text-box&quot;&gt;
    &lt;span class=&quot;square&quot;&gt;&lt;/span&gt;
    See the square next to me?
&lt;/span&gt;


.text-box &gt; .square {
    display: inline-block;
    width: 1rem;
    height: 1rem;
    background-color: red;
}
</code></pre><p>推荐</p>
<pre><code>&lt;!-- That&apos;s clean markup! --&gt;
&lt;span class=&quot;text-box&quot;&gt;
    See the square next to me?
&lt;/span&gt;


/* We use a :before pseudo element to solve the design problem of placing a colored square in front of the text content */
.text-box:before {
  content: &quot;&quot;;
  display: inline-block;
  width: 1rem;
  height: 1rem;
  background-color: red;
}
</code></pre><p>图片和 SVG 图形能被引入到 HTML 中的唯一理由是它们呈现出了与内容相关的一些信息。</p>
<p>不推荐</p>
<pre><code>&lt;!-- Content images should never be used for design elements!  --&gt;
&lt;span class=&quot;text-box&quot;&gt;
  &lt;img src=&quot;square.svg&quot; alt=&quot;Square&quot; /&gt;
  See the square next to me?
&lt;/span&gt;
</code></pre><p>推荐</p>
<pre><code>&lt;!-- That&apos;s clean markup! --&gt;
&lt;span class=&quot;text-box&quot;&gt;
  See the square next to me?
&lt;/span&gt;


/* We use a :before pseudo element with a background image to solve the problem */
.text-box:before {
  content: &quot;&quot;;
  display: inline-block;
  width: 1rem;
  height: 1rem;
  background: url(square.svg) no-repeat;
  background-size: 100%;
}
</code></pre><p>##Type 属性</p>
<p>省略样式表与脚本上的 type 属性。鉴于 HTML5 中以上两者默认的 type 值就是 text/css 和 text/javascript，所以 type 属性一般是可以忽略掉的。甚至在老旧版本的浏览器中这么做也是安全可靠的。</p>
<p>不推荐</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot; type=&quot;text/css&quot;&gt;
&lt;script src=&quot;main.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
</code></pre><p>推荐</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt;
&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
</code></pre><p>##可用性</p>
<p>如果 HTML5 语义化标签使用得当，许多可用性问题已经引刃而解。ARIA 规则在一些语义化的元素上可为其添上默认的可用性角色属性，使用得当的话已使网站的可用性大部分成立。假如你使用 nav, aside, main, footer 等元素，ARIA 规则会在其上应用一些关联的默认值。<br>更多细节可参考 ARIA specification</p>
<p>另外一些角色属性则能够用来呈现更多可用性情景（i.e. role=”tab”）。</p>
<p>##Tab Index 在可用性上的运用</p>
<p>检查文档中的 tab 切换顺序并传值给元素上的 tabindex，这可以依据元素的重要性来重新排列其 tab 切换顺序。你可以设置 tabindex=”-1” 在任何元素上来禁用其 tab 切换。</p>
<p>当你在一个默认不可聚焦的元素上增加了功能，你应该总是为其加上 tabindex 属性使其变为可聚焦状态，而且这也会激活其 CSS 的伪类 :focus。选择合适的 tabindex 值，或是直接使用 tabindex=”0” 将元素们组织成同一 tab 顺序水平，并强制干预其自然阅读顺序。</p>
<p>##微格式在 SEO 和可用性上的运用</p>
<p>如果 SEO 和可用性环境条件允许的话，建议考虑采用微格式。微格式是通过在元素标签上申明一系列特定数据来达成特定语义的方法。</p>
<p>谷歌、微软和雅虎对如何使用这些额外的数据一定程度上的达成一致，如果正确的使用，这将给搜索引擎优化带来巨大的好处。</p>
<p>你可以访问 schema.org 获得更多内容细节。</p>
<p>看一个电影网站的简单例子：</p>
<p>不带微格式</p>
<pre><code>&lt;div&gt;
 &lt;h1&gt;Avatar&lt;/h1&gt;
 &lt;span&gt;Director: James Cameron (born August 16, 1954)&lt;/span&gt;
 &lt;span&gt;Science fiction&lt;/span&gt;
 &lt;a href=&quot;../movies/avatar-theatrical-trailer.html&quot;&gt;Trailer&lt;/a&gt;
&lt;/div&gt;
</code></pre><p>带有微格式</p>
<pre><code>&lt;div itemscope itemtype =&quot;http://schema.org/Movie&quot;&gt;
  &lt;h1 itemprop=&quot;name&quot;&gt;Avatar&lt;/h1&gt;
  &lt;div itemprop=&quot;director&quot; itemscope itemtype=&quot;http://schema.org/Person&quot;&gt;
  Director: &lt;span itemprop=&quot;name&quot;&gt;James Cameron&lt;/span&gt; (born &lt;span itemprop=&quot;birthDate&quot;&gt;August 16, 1954)&lt;/span&gt;
  &lt;/div&gt;
  &lt;span itemprop=&quot;genre&quot;&gt;Science fiction&lt;/span&gt;
  &lt;a href=&quot;../movies/avatar-theatrical-trailer.html&quot; itemprop=&quot;trailer&quot;&gt;Trailer&lt;/a&gt;
&lt;/div&gt;
</code></pre><p>##ID 和锚点</p>
<p>通常一个比较好的做法是将页面内所有的头部标题元素都加上 ID. 这样做，页面 URL 的 hash 中带上对应的 ID 名称，即形成描点，方便跳转至对应元素所处位置。</p>
<p>打个比方，当你在浏览器中输入 URL <a href="http://your-site.com/about#best-practices，浏览器将定位至以下" target="_blank" rel="external">http://your-site.com/about#best-practices，浏览器将定位至以下</a> H3 上。</p>
<pre><code>&lt;h3 id=&quot;best-practices&quot;&gt;Best practices&lt;/h3&gt;
</code></pre><p>##格式化规则</p>
<p>在每一个块状元素，列表元素和表格元素后，加上一新空白行，并对其子孙元素进行缩进。内联元素写在一行内，块状元素还有列表和表格要另起一行。</p>
<p>（如果由于换行的空格引发了不可预计的问题，那将所有元素并入一行也是可以接受的，格式警告总好过错误警告）。</p>
<p>推荐</p>
<pre><code>&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Space&lt;/em&gt;, the final frontier.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Moe&lt;/li&gt;
  &lt;li&gt;Larry&lt;/li&gt;
  &lt;li&gt;Curly&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th scope=&quot;col&quot;&gt;Income&lt;/th&gt;
      &lt;th scope=&quot;col&quot;&gt;Taxes&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
          &lt;td&gt;$ 5.00&lt;/td&gt;
      &lt;td&gt;$ 4.50&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</code></pre><p>##HTML 引号</p>
<p>使用双引号(“”) 而不是单引号(”) 。</p>
<p>不推荐</p>
<pre><code>&lt;div class=&apos;news-article&apos;&gt;&lt;/div&gt;
</code></pre><p>推荐</p>
<pre><code>&lt;div class=&quot;news-article&quot;&gt;&lt;/div&gt;
</code></pre><p>[^1]:此处的空白元素指的是以下元素：area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/01/2017-3-11/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Rufer">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Rufer's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Rufer's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/2017-3-11/" itemprop="url">
                  css命名法-BEM命名法详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T23:40:02+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/01/2017-3-11/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/01/2017-3-11/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目。</p>
<p>命名约定的模式如下：</p>
<pre><code>.block{}  
.block__element{}  
.block--modifier{}  
</code></pre><ul>
<li>.block 代表了更高级别的抽象或组件。</li>
<li>.block__element 代表.block的后代，用于形成一个完整的.block的整体。</li>
<li>.block–modifier代表.block的不同状态或不同版本。</li>
</ul>
<p>之所以使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定，如：</p>
<pre><code>.site-search{} /* 块 */  
.site-search__field{} /* 元素 */  
.site-search--full{} /* 修饰符 */    
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/21/2017-2-21/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Rufer">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Rufer's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Rufer's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/21/2017-2-21/" itemprop="url">
                  我的前端之路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-21T22:38:45+08:00">
                2017-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/21/2017-2-21/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/21/2017-2-21/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>大家好，我是一个切图仔，现在在一家普通的公司做着普通的切图工作。现在是晚上10点钟，我正喝着香飘飘奶茶，在网易云音乐上听着武林外传电视剧。我的思绪随着故事里的对话飘到了很久以前：那时候我还在上初中，因为学校那边租的房子没有电视，为了我在租房那边有东西可以消遣，于是我在暑假的时候把mp3放在电视的播音口上，当武林外传开播，我就赶紧按下开始录音，当广告开始，我又马上从沙发上跳起来把录音关掉。。。结果到”验货”的时候发现好多录音都是杂音！气死我也。。。好像跑题了，本文的主题是我的职业之路，言归正传。。。</p>
<p>提问：我是如何走上前端这条不归路的？<br>回答：故事要追溯到2015年。。。</p>
<p>那时候我读大三，作为一名标准的死宅看动漫打游戏，偶尔弹弹琴文艺一下。时值大三结束之际，有先见之明的同志们已经筹备着即将到来的秋招。那时候的我用一个字形容就是”迷”：明明没有任何一家企业给我offer却有一种谜一样的淡定。。。</p>
<p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=0130ce837ad98d1076d40c39113eb807/19f09f3df8dcd100954ca05e748b4710b8122fb7.jpg" alt="淡定狗狗"></p>
<p>说心里不慌是不可能的，我一直觉得大学最重要的是确定自己要做什么，能为之多做一点准备更好。于是我在大三升大四的暑假选择留校在实验室。刚好那时候上的《web技术基础》这门课要交期末作业了，也就是用书本中尽量多的内容写一张网页，内容不限。于是我就照着书抄标签：能用的标签全部用上，最后一张应该被称为”html标签识别教学案例”的页面就这么诞生了。写完第一张页面，我心中不由得升起一股成就感(我也不知这成就感从何而来，毫无技术性可言的一张页面花了我一下午的时间)，更重要的是，在那段迷茫的时期我感觉有事情可做了：写页面！于是我认识了”前端”这个词，认识了”极客学院”、”慕课网”这些在线学习平台。我还心血来潮，买了一本当时不适合我的书，这本书我到现在还在看：《JavaScript高级程序设计》(第三版)<br>。拿到书的那天我煞有介事的带到学校的实验室看了一下午带一个晚上。可以很明白的说，那天我就看懂一句话：</p>
<blockquote>
<p>本书不适合没有计算机基础知识的初学者，也不适合只想为网站添加简单交互功能的读者。 <a href="原文出自《JavaScript高级程序设计》(第三版)。">^1</a> </p>
</blockquote>
<p>就算是这样，但是我拿着书看就有种谜一样的充实感。<br>这么跟着慕课网的老师们边学边做了一个暑假以后，大四上学期我开始找实习。终于在15年的10月份找到一家初创业公司内的实习工作，岗位是web前端实习生。</p>
<h2 id="工作与收获"><a href="#工作与收获" class="headerlink" title="工作与收获"></a>工作与收获</h2><p>由于公司主要做海外的业务，市场重心放在第三世界国家，所以我的很多工作就是”翻译”：把网站上的文本内容换成其他国家语言，趁此机会了解这样的功能是怎么实现的。现在看来就是一个很简单的工作:将页面上的文本翻译成各种国家的语言用json格式保存起来，以页面上的切换选项作为入口选择不同的语言跳转到当前页面并加上”?lan=xx”的后缀，在页面加载时分析url的fragment部分并根据解析出的值来加载不同的语言。当时我可是研究了很久才弄明白。在公司里，如果没有事情做，我就找技术论坛和社区看文章。那时候也为隔壁的移动端部门做了几张app宣传页面，借此机会对移动端手势事件做了一些了解，知道了移动端点击事件延迟300ms的原理，知道了rem单位可以用来做响应式布局。回想那段实习的日子可真是苦啊，尤其是一月底那段时间，早上6点半的时候就起来，天刚刚亮的时候我就已经到了轻轨站。一路上是又上天（轻轨）又下海（过江隧道），还要走40多分钟的路，最后还只能踩着点到公司。现在想一想，当时我是怎么熬过来的，估计只有当时的我才知道吧。</p>
<p>毕业以后，我又找了一份注重于页面的工作（也就是现在的工作）。工资不高，但是有一个厉害的老大。抱着向前辈多学习的想法，我开始了我的页面工程师的生涯。</p>
<p>工作的内容就是页面重构：按照视觉稿的要求写新的页面或者修改旧的页面。在这里我接触了新的工具：gulp和git，以及新的语言：jade+sass；知道了ui组件的模块化是怎么回事：将页面按照页头、页脚、侧边栏等板块拆分出一个个组件，分别对组件进行管理与维护。在读懂了公司的gulpfile.js之后，我在自己的电脑上也配置了一套页面重构的环境，学会了npm包管理工具的配置方法和gulp自动化构建工具的配置技巧。</p>
<p>有的时候我也会写用户交互用的js，曾经有一位同事跟我说了代码编写要符合规范，因为我的代码让人一看就不想看下去，很乱。于是我开始注意css与js编写的规范，在查阅了大量的资料后，我渐渐养成了干净、整洁的编码习惯。</p>
<p>由于公司内的功能交互是依赖于jQuery库的，我有时会和同事一起解决交互功能的问题。这个时候我又发现了代码的质量影响到页面的性能。由此我明白了事件委托原理，函数防抖与节流原理，事件队列原理。在应用这些方法的时候，我感觉自己的代码水平又提高了一层。</p>
<p>在这家公司里我养成了记笔记的习惯：发现有好的文章，我就记下链接保存在我的笔记中。这些笔记到现在我都认为有保存下来的价值。</p>
<p>在这家公司我还使用es6+react过了一把瘾：公司里要求做一个文字冒险游戏主题编辑器，老大将架子搭好以后就丢给了我，由我解决后续的需求。那一个月里面我又重新开始学es6规范的js，为此我买了第三本书：阮一峰老师的《ES6标准入门》(第二版)。由于对react框架不熟，对新的语法也不熟，我写每一段代码都很艰难。至今都没有把握说懂了react框架或是es6语法。</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><p>今年是我正式踏入社会的第二年。我坚信保持学习，提升个人价值是我近两年的第一目标。所以我对自己今年的期望，就是比去年获取有效知识的效率更高，解决bug的速度更快，做一个高效率的开发者。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Rufer" />
          <p class="site-author-name" itemprop="name">Rufer</p>
           
              <p class="site-description motion-element" itemprop="description">江大第一切图仔。</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rufer</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"miller547719886"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


</body>
</html>
