---
title: EventLoop深入探究
date: 2018-01-22 22:30:48
tags: javascript
---

## 出题

我们从一道经典的题目开始探索：

```javascript
setTimeout(function(){console.log(4)},0);
new Promise(function(resolve){
    console.log(1)
    for( var i=0 ; i<10000 ; i++ ){
        i==9999 && resolve()
    }
    console.log(2)
}).then(function(){
    console.log(5)
});
console.log(3);
```

## 结果

1
2
3
5
4

是否和你的答案一致？

<!-- more -->

## 涉及概念

* EventLoop(事件循环)
* task queue(任务队列,又称macrotask queue)
* microtask queue(微任务队列)
* task source(任务源)

## 分析依赖

为了保证分析的依据是最权威的，我花了点时间翻译了W3C的文档。

按照W3C文档的说明，找到了如下资料：

```
An event loop has one or more task queues. A task queue is an ordered list of task
```

翻译一下：一个EventLoop(事件循环)内有一个到多个task queue(任务队列,又称macrotask queue)，一个task queue(任务队列,又称macrotask queue)是一个任务的有序列表。

在这之前还有一句话：

```
There must be at least one browsing context event loop per user agent, and at most one per unit of related similar-origin browsing contexts.
```

翻译过来是：一个浏览器环境最多会有一个EventLoop(事件循环)。

还有一段内容：

```
Each task is defined as coming from a specific task source. All the tasks from one particular task source and destined to a particular event loop (e.g., the callbacks generated by timers of a Document, the events fired for mouse movements over that Document, the tasks queued for the parser of that Document) must always be added to the same task queue, but tasks from different task sources may be placed in different task queues.
```

翻译为：每个任务都由一个特定的任务源来定义。所有的任务，由同一个任务源生成的任务必须加入同一个任务队列，但从不同的任务来源任务被放置在不同的任务队列。

文档对于EventLoop(事件循环)的运行机制给出如下解释：

英文太长就不贴出来了，有兴趣的自己看[event-loops-definitions](https://www.w3.org/TR/html5/webappapis.html#event-loops-definitions)

翻译的结果：

只要EventLoop(事件循环)存在，它必须持续运行以下步骤:

1. 选择EventLoop(事件循环)的task queue(任务队列,又称macrotask queue)中的最老任务(在浏览器环境下忽略与之关联的文档不活动的任务)，这个任务可以来自于存在的任何task queue(任务队列,又称macrotask queue)。如果找不到任何task queue(任务队列,又称macrotask queue)，会跳到下面的microtask queue(微任务队列)步骤。

2. 将事件循环当前运行的任务设置为上一步中选定的任务。

3. 运行选定的任务。

4. 将EventLoop(事件循环)当前运行的任务设置为null。

5. 从它的task queue(任务队列,又称macrotask queue)中删除在run步骤中运行的任务。

6. microtask queue(微任务队列)：执行一个微任务关卡。

7. 回到第一步。

### 宏任务，微任务与任务源

macro-task与micro-task的具体分类，按照[promiseA+](http://www.ituring.com.cn/article/66566)中的一段介绍如下：

宏任务（macro-task）: 
* script（整体代码）
* setTimeout
* setInterval
* setImmediate
* I/O
* UI rendering

微任务（micro-task）: 
* process.nextTick
* Promises（这里指浏览器实现的原生 Promise）
* Object.observe(已废弃)
* MutationObserver(html5新特性)

微任务中已知这样的关系：

> “process.nextTick 永远大于 promise.then，原因其实很简单。。。在Node中，\_tickCallback在每一次执行完TaskQueue中的一个任务后被调用，而这个\_tickCallback中实质上干了两件事：1. nextTickQueue中所有任务执行掉(长度最大1e4，Node版本v6.9.1)2.第一步执行完后执行\_runMicrotasks函数，执行microtask中的部分(promise.then注册的回调)所以很明显process.nextTick > promise.then”


setTimeout/Promise等我们称之为**任务源**。而进入任务队列的是他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中`setTimeout`与`setInterval`是同源的。

事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。

其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。

promise相关：
[promiseaplus.com](https://promisesaplus.com/differences-from-promises-a)

当中有一条：

`onFulfilled and onRejected must be called asynchronously;`

翻译为：onFulfilled与onRejected状态必须被同步调用。

## 正式分析

以上面所述信息为我们判断的基本依据，首先script(整体代码)是一个macro-task,所以会被首先推入到task queue(任务队列,又称macrotask queue)中在EventLoop(事件循环)内执行。

执行过程中发现了有setTimeout，将其提出，放入一个新的task queue(任务队列,又称macrotask queue)中，等待执行。

执行过程中发现有Promise的resolve回调,根据`onFulfilled and onRejected must be called asynchronously;`这一原则，它将会被认作为普通的同步事件普通的执行。到此处**打印出1,2**。

执行过程中发现了有Promise.then，将其提出，放入microtask queue(微任务队列)中，等待执行。

往下执行发现console.log(3),作为普通的同步事件执行，到此处**打印出3**。

此时第一个task queue(任务队列,又称macrotask queue)执行完毕，按照上面的顺序，现在应该执行microtask queue(微任务队列)里的所有任务了。发现有一个console.log(5)，执行它。到此处**打印出5**。

microtask queue(微任务队列)里的所有任务已经执行完毕，该执行下一个task queue(任务队列,又称macrotask queue)了。发现console.log(4)，执行它。到此处**打印出4**。

此时EventLoop(事件循环)当前任务为null，寻找microtask queue(微任务队列)中是否有未完成任务，发现没有；

寻找task queue(任务队列,又称macrotask queue)中是否有未完成任务，发现没有；

EventLoop当前任务保持为null，到此全部事件执行结束。


## 再次出题

```javascript
// 此demo需在node环境下运行
console.log('golb1');

setTimeout(function() {
    console.log('timeout1');
    process.nextTick(function() {
        console.log('timeout1_nextTick');
    })
    new Promise(function(resolve) {
        console.log('timeout1_promise');
        resolve();
    }).then(function() {
        console.log('timeout1_then')
    })
})

setImmediate(function() {
    console.log('immediate1');
    process.nextTick(function() {
        console.log('immediate1_nextTick');
    })
    new Promise(function(resolve) {
        console.log('immediate1_promise');
        resolve();
    }).then(function() {
        console.log('immediate1_then')
    })
})

process.nextTick(function() {
    console.log('glob1_nextTick');
})
new Promise(function(resolve) {
    console.log('glob1_promise');
    resolve();
}).then(function() {
    console.log('glob1_then')
})

setTimeout(function() {
    console.log('timeout2');
    process.nextTick(function() {
        console.log('timeout2_nextTick');
    })
    new Promise(function(resolve) {
        console.log('timeout2_promise');
        resolve();
    }).then(function() {
        console.log('timeout2_then')
    })
})

process.nextTick(function() {
    console.log('glob2_nextTick');
})
new Promise(function(resolve) {
    console.log('glob2_promise');
    resolve();
}).then(function() {
    console.log('glob2_then')
})

setImmediate(function() {
    console.log('immediate2');
    process.nextTick(function() {
        console.log('immediate2_nextTick');
    })
    new Promise(function(resolve) {
        console.log('immediate2_promise');
        resolve();
    }).then(function() {
        console.log('immediate2_then')
    })
})
```

代码比较长，没关系，我们先概览一遍。

首先整个代码段被分配在一个task queue(任务队列,又称macrotask queue)中执行，第一行发现一个同步事件`console.log('golb1');`，直接执行；到此处**打印出golb1**。

往下执行，发现一个setTimeout事件（timeout1），根据上节提供的信息，setTimeout为一个macro-task，会新建一个task queue(任务队列,又称macrotask queue)并将该任务置于栈顶(命名该任务队列为macro-t，此时队列中有一个事件timeout1)。

继续往下执行，发现一个setImmediate事件（immediate1），根据上节提供的信息，setImmediate为一个macro-task，会新建一个task queue(任务队列,又称macrotask queue)并将该任务置于栈顶。(命名该任务队列为macro-i，此时队列中有一个事件immediate1)。

继续往下执行，发现一个process.nextTick事件。根据上节提供的信息，process.nextTick为一个micro-task，会将该任务置于新建的microtask queue(微任务队列)的栈顶。（命名该任务队列为micro-n，此时队列中有一个事件glob1_nextTick）

继续往下执行，发现一个Promise事件。根据上节提供的信息，Promise实例内的函数为一个同步事件，包括resolved事件。故执行，到此处**打印出glob1_promise**，而其后的then中的代码段为一个micro-task，会将该任务推送到新建的microtask queue(微任务队列)中（命名为micro-t）排队等待执行(此时队列中有一个事件glob1\_then)。

往下执行，发现一个setTimeout事件（timeout2），根据上节提供的信息，setTimeout为一个macro-task，且任务源为setTimeout，由于之前已经新建了一个setTimout专用的task queue(任务队列,又称macrotask queue)，故将该任务推送到该队列中（macro-t）排队等待执行（此时队列中事件按执行先后顺序有timeout1，timeout2）。

继续往下执行，发现一个process.nextTick事件。根据上节提供的信息，process.nextTick为一个micro-task，且之前有创建process.nextTick专用队列（micro-n），所以会将该任务推送到该队列中micro-n中排队等待执行(此时队列中有事件glob1\_nextTick,glob2\_nextTick)。

继续往下执行，发现一个Promise事件。根据上节提供的信息，Promise实例内的函数为一个同步事件，包括resolved事件。故执行，到此处**打印出glob2_promise**，而其后的then中的代码段为一个micro-task，由于之前已经新建了一个promise.then专用队列(micro-t),会将该任务推送到该队列中排队等待执行（此时队列中事件按执行先后顺序有glob1\_then，glob2\_then）。

继续往下执行，发现一个setImmediate事件（immediate2），根据上节提供的信息，setImmediate为一个macro-task，由于之前已经新建了一个setImmediate专用的task queue(任务队列,又称macrotask queue)，故将该任务推送到该队列中（macro-i）排队等待执行（此时队列中事件按执行先后顺序有immediate1，immediate2）。

此时第一个队列任务执行完毕，开始寻找所有可执行的微任务。由上面累积的微任务队列有两个：process.nextTick的任务队列(micro-n)与Promise.then的任务队列(micro-t)，而根据上节中提到的process.nextTick与Promise.then的关系得知，micro-n先执行，故**先后打印出glob1\_nextTick与glob2\_nextTick**。

随后micro-t执行，故**先后打印出glob1\_then与glob2\_then**。

至此所有微任务被清空，寻找所有可执行的宏任务：有setTimeout的任务队列(macro-t)与setImmediate的任务队列(macro-i)

两种队列的先后执行关系没有有力资料可以印证，所以我们到此处分析先暂停，把所有结果打出来看看：

```javasacript
// 结果
golb1
glob1_promise
glob2_promise
glob1_nextTick
glob2_nextTick
glob1_then
glob2_then
timeout1
timeout1_promise
timeout2
timeout2_promise
timeout1_nextTick
timeout2_nextTick
timeout1_then
timeout2_then
immediate1
immediate1_promise
immediate2
immediate2_promise
immediate1_nextTick
immediate2_nextTick
immediate1_then
immediate2_then
```

可以看到我们之前的分析都得到了证明，而后面的打印结果说明了：setImmediate的执行顺序是排在setTimeout之后的。那是否有可能是由于代码顺序导致的队列排序先后？我们针对这两个宏任务做实验：

```javascript
setImmediate(function() {
    console.log('immediate1');
    process.nextTick(function() {
        console.log('immediate1_nextTick');
    })
    new Promise(function(resolve) {
        console.log('immediate1_promise');
        resolve();
    }).then(function() {
        console.log('immediate1_then')
    })
})

setTimeout(function() {
    console.log('timeout1');
    process.nextTick(function() {
        console.log('timeout1_nextTick');
    })
    new Promise(function(resolve) {
        console.log('timeout1_promise');
        resolve();
    }).then(function() {
        console.log('timeout1_then')
    })
})
```

这次我们刻意将setImmediate代码段排在setTimeout前面，再看看执行结果：

```javascript
timeout1
timeout1_promise
timeout1_nextTick
timeout1_then
immediate1
immediate1_promise
immediate1_nextTick
immediate1_then
```

到此我们至少可以得到一个结论：在node环境下，setTimeout队列会先于setImmediate执行。

## 结论

一个浏览器环境中只有一个事件循环（event loop），一个事件循环中可以有多个任务队列，任务队列又分宏队列（macrotask queue）和微队列（microtask queue），每个任务队列由任务源为单位创建，其中setTimeout与setInterval为同一个任务源。

事件循环从一个宏任务队列开始（一般是整体代码），如果该宏队列任务全部执行完毕则寻找所有可执行的微任务队列按照任务源的优先级的顺序执行，当所有微任务都执行完毕则寻找所有可执行的其他宏任务队列。如此往复循环直至没有可执行的宏任务为止。

宏任务源类型：

* script（整体代码）
* setTimeout
* setInterval
* setImmediate
* I/O
* UI rendering

其中测试得知，在node环境中，setTimeout/setInterval队列比setImmediate队列优先执行。

微任务源类型：

* process.nextTick
* Promises（这里指浏览器实现的原生 Promise）
* Object.observe(已废弃)
* MutationObserver(html5新特性)

其中process.nextTick任务队列比Promise.then任务队列优先执行。

## 参考资料

[任务队列执行可视化](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&utm_medium=email)
[w3.org-EventLoop](https://www.w3.org/TR/html5/webappapis.html#event-loops)
[MDN-EventLoop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
[阮一峰-JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)