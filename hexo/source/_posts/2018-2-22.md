---
title: '从倒计时的实现深入探究setTimout与setInterval'
date: 2018-02-22 22:32:35
tags: javascript
---

## 拜年

新年伊始，本搬砖汪先给各位老爷们拜个晚年，祝各位技术大牛们在新的一年代码功底更进一步，家庭幸福美满！

## 需求

下面进入正题：在翻阅segmentfault社区时看到某巨厂面试要求实现一个倒计时功能，之前也没有仔细实现过，趁年初来任务还没来得及分配，赶紧着手实现了一个。

## 第一版

```javascript
var period = 60*1000*60*2
var end = new Date().getTime() + period
var date = new Date(end)
var interval = 1000

function loopInner() {
  var diff = end - new Date().getTime()
  var h = Math.floor(diff / (60*1000*60))
  var hdiff = diff % (60*1000*60)
  var m = Math.floor(hdiff / (60*1000))
  var mdiff = hdiff % (60*1000)
  var s = mdiff / 1000
  var sCeil = Math.ceil(s)
  console.log(h, m, s, sCeil)
}

function loop() {
  loopInner() // 首先
  return setTimeout(loop, interval)
}

loop()
```

<!-- more -->

结果如下：

![code_1](2018-2-22/code_1.png)

第一版实现我使用的是递归的setTimeout方法，原因是之前曾经看到过递归的setTimeout能避免setInterval忽视代码执行时间，而一个事件队列里只会有一个setInterval事件导致的部分setInterval事件被忽略的情况。这么执行导致的结果是每次setTimeout的时间必然会大于1000ms（1000 + 主线程代码执行消耗的时间），而当这个**主线程代码执行消耗的时间**累加起来超过1s时，就会出现跳一秒的情况。这一版实现方案的结果不尽如人意。

## 第二版

```javascript
var period = 60 * 1000 * 60 * 2
var end
var date = new Date(end)
var interval = 1000
var loop = function () {
  if (!end) { end = new Date().getTime() + period }
  var diff = end - new Date().getTime()
  var h = Math.floor(diff / (60 * 1000 * 60))
  var hdiff = diff % (60 * 1000 * 60)
  var m = Math.floor(hdiff / (60 * 1000))
  var mdiff = hdiff % (60 * 1000)
  var s = mdiff / (1000)
  var roundS = Math.round(s)
  console.log(h, m, s, roundS)
}
setInterval(loop, interval)
```

结果如下：

![code_2](2018-2-22/code_2.png)

这一版的结果比较接近正确答案，利用setInterval不等待执行代码完成就直接加入队列的特性（参考[setInterval与setTimeout的精确度问题](http://www.cnblogs.com/youxin/p/3354924.html)），再加上用Math.round方法修正js的异步方法所造成的几毫秒的误差即可。而setInterval毕竟也是浏览器的api，同样是有几毫秒的差异的，这样的差异叠加数量过大，会造成与标准时间相隔几秒甚至几十秒的情况。

## 最终版

在参阅大量资料后，我选择在第一种写法的基础上做改良：每次循环中基于此次代码执行所消耗的时间对下次循环所消耗的时间间隔做修正。

```javascript
var period = 60 * 1000 * 60 * 2
var startTime = new Date().getTime();
var count = 0
var end = new Date().getTime() + period
var interval = 1000
var currentInterval = interval

function loop() {
  count++
  var offset = new Date().getTime() - (startTime + count * interval); // 代码执行所消耗的时间
  var diff = end - new Date().getTime()
  var h = Math.floor(diff / (60 * 1000 * 60))
  var hdiff = diff % (60 * 1000 * 60)
  var m = Math.floor(hdiff / (60 * 1000))
  var mdiff = hdiff % (60 * 1000)
  var s = mdiff / (1000)
  var sCeil = Math.ceil(s)
  var sFloor = Math.floor(s)
  currentInterval = interval - offset // 得到下一次循环所消耗的时间
  var j = 0
  while (j<100000000) { // 放大主线程代码执行时间
    j++
  }
  console.log('时：'+h, '分：'+m, '毫秒：'+s, '秒向上取整：'+sCeil, '代码执行时间：'+offset, '下次循环间隔'+currentInterval) // 打印 时 分 秒 代码执行时间 下次循环间隔

  setTimeout(loop, currentInterval)
}

setTimeout(loop, currentInterval)
```

结果如下：

![code_3](2018-2-22/code_3.png)

## 参考资料

[JS实现活动精确倒计时](https://www.xuanfengge.com/js-realizes-precise-countdown.html)
[w3.org](https://www.w3.org/TR/animation-timing/)
[javascript线程解释（setTimeout,setInterval你不知道的事）](http://www.cnblogs.com/youxin/p/3354924.html)

