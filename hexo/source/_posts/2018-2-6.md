---
title: javascript中隐式转换
date: 2018-02-06 10:57:57
tags:
---

## javascript是弱类型语言

之前记录过一篇文章区分了高级语言可以按照类型检查的严格程度分为强/弱类型语言，按照类型检查的时间点分为静态/动态类型语言。按照上篇文章所述，javascript是弱类型、动态检查的语言。这种语言的灵活性很高（不同类型的值可以做运算），但是也会更危险。如果对操作符的运算规则不熟悉，很可能造成自己意想不到的结果，从而导致对bug无从下手。

## js中的+运算符

在js中，由于其隐式转换的特性随时有可能发生，经常会出现奇怪的现象，比如下面的语句：

```javascript
[] + []

"" // 返回结果
```

js中提供不同严格程度的类型检查，比如说`use strict`（严格模式），或者是不严格相等与严格相等（==/===）。不严格相等的相等判断规则可以列一长条出来，就算是看起来完全不同的两种值都可能被判断为相等，所以其严谨程度经常为人所诟病。就拿上面的例子来分析，看`+`是如何工作的。

<!-- more -->

## 原始类型转换表

原始值 | 对应数值类型 | 对应字符串类型 | 对应boolean类型 |
 ---  | --- | --- | --- |
false | 0 | "false" | false
true | 1 | "true" | true
0 | 0 | "0" | false
1 | 1 | "1" | true
"0" | 0 | "0" | true
"1" | 1 | "1" | true
NaN | NaN | "NaN" | false
Infinity | Infinity | "Infinity" | true
-Infinity | -Infinity | "-Infinity" | true
"" | 0 | "" | false
"20" | 20 | "20" | true
"twenty" | NaN | "twenty" | true
[] | 0 | "" | true
[20] | 20 | "20" | true
[10, 20] | NaN | "10,20" | true
["twenty"] | NaN | "twenty" | true
["ten", "twenty"] | NaN | "ten, twenty" | true
function(){} | NaN | "function(){}" | true
{} | NaN | "[object Object]" | true
null | 0 | "null" | false
undefined | NaN | "undefined" | false

上表陈列了js中的原始值转换为数字、字符串、布尔类型后对应的结果，可供查阅。

可以见到上面的转换内容没有覆盖所有的情况，还提出了一个**原始值**的概念。什么是原始值？

## 原始值与toPrimiitive方法

这里搬运一段w3school的原句：

> 原始值:
  存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。
  引用值:
  存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。
  ECMAScript 有 5 种原始类型（primitive type），即`Undefined, Null, Boolean, Number, String`。ECMA-262 把术语类型（type）定义为值的一个集合，每种原始类型定义了它包含的值的范围及其字面量表示形式。

可以见得，原始类型值就是俗称的基本类型值，其传递类型为值传递；引用类型值就是俗称的复杂类型值，其传递类型为引用传递。那引用值如何转换成原始值？

在js引擎中有一个内置方法：`toPrimitive(obj, jsType)`用于将复杂类型值转换为原始值，让我们解读一下其工作原理。

ToPrimitive运算符接受一个值，和一个可选的**期望类型**作参数(可选值String与Number，默认值为无。)。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原始值，可以使用可选的**期望类型**来暗示那个类型，并返回该对象的默认值。对象的默认值由把期望类型传入作为参数调用对象的内部方法[[DefaultValue]]得到。这个[[DefaultValue]]又是啥？不慌，往下看。

### [[DefaultValue]] (hint)

关于[[DefaultValue]]的详细规则请看[w3c规范](http://yanhaijing.com/es5/#null)中的8.12.8节，下面是我的解读：

当用字符串 hint 调用 O 的 [[DefaultValue]] 内部方法（即toPrimitive的期望类型为String），采用以下步骤：

1. 否则,调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.
2. 调用该对象的valueOf()方法.如果valueOf()方法的返回值是一个原始值,则返回这个原始值.
3. 否则,抛出TypeError异常.

当用数字 hint 调用 O 的 [[DefaultValue]] 内部方法（即toPrimitive的期望类型为Number），采用以下步骤：

1. 调用该对象的valueOf()方法.如果valueOf()方法的返回值是一个原始值,则返回这个原始值.
2. 否则,调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.
3. 否则,抛出TypeError异常.

> 如果没有指定期望类型,则期望类型的值会按照这样的规则来自动设置:Date类型的对象会被设置为String（即先执行toString后执行valueOf）,其它类型的值会被设置为Number（即先执行valueOf后执行toString）。经试验证明，toPrimitive方法内置于js引擎中，不会有人去改写这个期望类型参数，所以基本就按照这个规则来判断就是了。


下面列出一下常见的复杂类型值的valueOf与toString结果：

原始值 | valueOf | toString |
 ---  | --- | --- |
[] | 0 | "false" 
[1] | [] | "" 
[1] | [1] | "1" 
[1, 2] | [1, 2] | "1,2" 
[{name: 'bob'}] | [{name: 'bob'}] | "[object Object]" 
{} | {} | "[object Object]" 
{name: 'bob'} | {name: 'bob'} | "[object Object]" 
{name: []} | {name: []} | "[object Object]" 
function () {} | function () {} | "function () {}" 
new Date() | 1517903643452 | "Tue Feb 06 2018 15:54:34 GMT+0800 (中国标准时间)" 
Math| Math | "[object Math]" 
RegExp| ƒ RegExp() { [native code] } | "function RegExp() { [native code] }" 

在转化为原始值之后，再按照上表所示规则转换为指定类型的的原始值（字符串或数字）

写个demo验证一下：

```javascript
var obj1 = {
    valueOf: function () {
        console.log("valueOf");
        return {}; // 没有返回原始值
    },
    toString: function () {
        console.log("toString");
        return '1'; // 没有返回原始值
    }
};
var obj2 = {
    valueOf: function () {
        console.log("valueOf");
        return 2; // 没有返回原始值
    },
    toString: function () {
        console.log("toString");
        return {}; // 没有返回原始值
    }
}
obj1+obj2

// 结果
valueOf
toString
valueOf
"12"
```

可以见得，`v1 + v2`这一语句可以用如下伪代码实现：

```javascript
var prim1 = ToPrimitive(v1)
var prim2 = ToPrimitive(v2)
var res
// PreferredType被省略,因此Date类型的值采用String,其他类型的值采用Number.

if (isNumber(prim1) || isNumber(prim1)) { // 如果其中一个值为String类型
  res = String(prim1) + String(prim1) // 则两个值都转换为字符串相加
} else { // 否则
  res = Number(prim1) + Number(prim2) // 则两个值都转换为数字相加
}

return res
```

下面我们用几个例子验证一下：

```javascript
true + 1 // 两个值都不是字符串类型，结果为转换为数字相加，根据上面表中对应关系得到结果为1

undefined + 1 // 两个值都不是字符串类型，结果为转换为数字相加，根据上面表中对应关系得到结果为NaN

let obj = {};
obj + 1 // 执行ToPrimitive(obj)得到"[object Object]"为字符串，与1相加结果为字符串，所以为"[object Object]1"
```

## 例外

```javascript
{} + 1 // 结果为1
```

造成这种情况的原因是整个输入被解析成了一个语句,如果一个语句是以左大括号开始的,则这对大括号会被解析成一个代码块。

```javascript
{
  // do nothing;
};
+1; // 这里的加号并不是代表加法的二元运算符,而是一个一元运算符,作用是将它后面的操作数转换成数字,和Number()函数完全一样

// 结果
1
```

同样还有如下情况：

```javascript
{} + [] // 结果为0
```

按照上面的逻辑，计算结果应为Number([])的结果。

```javascript
Number([])
Number([].toString())  // 因为[].valueOf()不是原始值
Number("")
0
```

## 不严格相等的判断规则

`==`的判断逻辑点[这里](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3)查阅，可以通过下面例子验证一下正确性：

```javascipt
[] == ![] // true
NaN !== NaN // true

1 == true // true
2 == true // false
"2" == true // flase

null > 0 // false
null < 0 // false
null == 0 // false
null >= 0 // true
```

## 参考文献

[w3c规范镜像版](http://yanhaijing.com/es5/#null)
[JavaScript 运算符规则与隐式类型转换详解](https://segmentfault.com/a/1190000011007975)
[JavaScript中,{}+{}等于多少?](https://www.cnblogs.com/ziyunfei/archive/2012/09/15/2685885.html)
[ECMAScript®语言规范](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3)