---
title: 从一道面试题理解JavaScript中的this
date: 2017-03-13 01:03:54
categories: 前端
tags:
  - JavaScript
---
## 问题
闲话少说，先上题目：

	var x = 20;
	var a = {
	    x: 15,
	    fn: function() {
	        var x = 30;
	        return function() {
	            return this.x;
	        };
	    }
	};
	console.log(a.fn());
	console.log((a.fn())());
	console.log(a.fn()());
	console.log(a.fn()() === (a.fn())());
	console.log(a.fn().call(this));
	console.log(a.fn().call(a));

各位心里是否已经有了答案？
现在公布正确答案：

<!-- more -->


	function() {
        return this.x;
    };
	20
	20
	true
	20
	15

现在来从头开始分析：
首先在window对象下挂载了一个x对象值为20;
接下来在window对象下挂载了一个a对象，内部挂载一个x对象值为15，一个fn对象值为一个函数表达式，函数返回结果为当前调用该函数的对象下挂载的x的值。

## Q1

第一个a.fn():
我们知道var a = function() {}这种形式的赋值，打印a输出的就是该函数表达式，打印a()得到的就是函数执行完后的返回值，也就是return的值，如果没有return，就默认返回undefined(参考JavaScript语言精粹(修订版)第31页-返回(return)一节的倒数第二段内容)。
所以这里如果是打印a.fn，那么结果将是

	function() {
        var x = 30;
        return function() {
            return this.x;
        };
    }	

而打印a.fn(),也就是打印这个方法return的结果，该方法return的还是一个函数，那就打印出来呗：

	function() {
        return this.x;
    };

## Q2

第二个：(a.fn())()

在看第二个问题之前，建议先看一下阮一峰老师的[Javascript的this用法](http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html)。

第二个其实就是执行第一问所打印出的函数啦，将a.fn()包起来的括号可有可无，只是有的话更能突出最后一个括号的"执行"的含义。

看了阮一峰老师关于this的文章以后，我们知道了this的4种使用情况：

1. 纯粹的函数调用
2. 作为对象方法的调用
3. 作为构造函数调用
4. apply/call调用

那么一步步来：a.fn是a对象下面的方法；
a.fn()是a对象下面方法执行后返回的结果，结果还是一个函数；
(a.fn())()是a对象下面方法执行后返回的结果(还是一个函数，还可以执行并返回结果)执行并返回的结果。
也就是说到最后其实上面的(a.fn())()说白了就是执行这个函数并返回结果：

	function() {
        return this.x;
    };

返回的结果是this.x，我们根据this的4中使用情况一一排除分析：
这里有apply或call方法吗？没有，第四种情况排除；
这是一个构造函数吗？整段代码没有new关键词，第三种情况排除；
这是一个对象方法的调用吗？看到a.fn()，我还真以为这就是在a对象下面的调用了。的确，我们调用了a对象下面的fn方法，得到了一个返回值。可是我们有在a对象下面的fn这一层作用域中使用过this吗？如果在这一层中我们使用某个变量保存了this的值并在后续的返回值中使用，那代码运行的结果还真可能不一样。比如我们改一改代码：

	var x = 20;
    var a = {
        x: 15,
        fn: function() {
            var xx = this.x;
            return function() {
                return xx;
            };
        }
    };

这下结果将变成

	function() {
        return this.x;
    };
	15
	15
	true
	15
	15

因为我们在fn所指向的function中保存了this.x，这里的this就指向a对象。为什么？因为fn是a对象下的方法。那么我们这里的(a.fn())()是不是a对象下的方法呢？人家就只是一个返回值，只是我们借a对象下的fn方法之手得到的一个返回值而已！问题到这里，就简化成了：

执行一个

	function() {
        return this.x;
    };

这样的函数中，this指向谁？

相信大家都知道答案了吧。第二问答案：window对象下的x，也就是20；

## Q3

第三问a.fn()()同第二问，答案20；

##Q4

第四问a.fn()() === (a.fn())()就是在问：第三问的答案是否全等于第二问的答案？

	20 === 20 

这个判断的返回值为true不用多说；

## Q5

第五问a.fn().call(this)：

不管前面是什么函数，我们在全局环境下调用xxxx().call(this)，这个this都指代window。

即是说我们传window对象为a.fn()函数的this的指代对象。

我们再来看看call()方法的定义：

> call方法可以用来代替另一个对象调用一个方法。call方法可以将一个函数的对象上下文从初始上下文改变为call()中指定的新对象。

我们看看call方法的用法：

	var func=new function(){this.a="func"}   
    var myfunc=function(x){   
        var a="myfunc";   
        alert(this.a);   
        alert(x);   
    }   
    myfunc.call(func,"var");

可见myfunc为函数名，后跟call方法后改变了this的指向**并调用了该方法**。

在理解以上概念的基础上，这个返回结果就是window.x = 20就很容易理解了。

## Q6

第六问a.fn().call(a)：

同第五问，我们将a.fn()内部的this对象绑定为a，那么this.x就是a.x就是15。

